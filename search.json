[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Advanced R Workbook",
    "section": "",
    "text": "1 Introduction\nThis is my code and answers for questions in the Advanced R (2nd edition) book",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "index.html#motivation",
    "href": "index.html#motivation",
    "title": "Advanced R Workbook",
    "section": "1.1 Motivation",
    "text": "1.1 Motivation\nThere currently exists an amazing Advanced R Solutions book with clearly worked answers. This workbook retreads the same steps, while applying a more functional coding style. In English - more piping, fewer side effects. I also just like learning R :)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "1_chapter2.html",
    "href": "1_chapter2.html",
    "title": "2  Names and values",
    "section": "",
    "text": "2.1 Quiz",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Names and values</span>"
    ]
  },
  {
    "objectID": "1_chapter2.html#quiz",
    "href": "1_chapter2.html#quiz",
    "title": "2  Names and values",
    "section": "",
    "text": "2.1.1 Quiz 1\nGiven the following data frame, how do I create a new column called “3” that contains the sum of 1 and 2? You may only use $, not [[. What makes 1, 2, and 3 challenging as variable names?\n\n\n\n\n\n\n\n\n\nAnswer\n1 and 2 and 3 are challenging as variable names since they are non-syntactic names. Though they can still be used (here) via coercing:\n\n\n\n\n\n\n\n\n\n\n\n2.1.2 Quiz 2\nIn the following code, how much memory does y occupy?\n\nx &lt;- runif(1e6)\ny &lt;- list(x, x, x)\n\n\nAnswer\nIn this code, y takes slightly more memory than x, but not 3 times more (only 80 bytes). This is because y is a list containing 3 references to the 1 vector underlying x. List structure takes up 80 bytes, the vector takes up 8MB.\n\nlobstr::obj_size(x)\n\n8.00 MB\n\nlobstr::obj_size(y)\n\n8.00 MB\n\nlobstr::obj_size(y) - lobstr::obj_size(x)\n\n80 B\n\n\n\n\n\n2.1.3 Quiz 3\nOn which line does a get copied in the following example?\n\na &lt;- c(1, 5, 3, 2)\nb &lt;- a\nb[[1]] &lt;- 10\n\n\nAnswer\na gets copied at line 3 of previous block b[[1]] &lt;- 10, since that is when b is modified and a new vector is created to contain data that b points to.",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Names and values</span>"
    ]
  },
  {
    "objectID": "1_chapter2.html#binding-basics",
    "href": "1_chapter2.html#binding-basics",
    "title": "2  Names and values",
    "section": "2.2 Binding basics",
    "text": "2.2 Binding basics\n\n2.2.1 Ex. 1\nExplain the relationship between a, b, c, and d in the following code:\n\nAnswers\n\na points to a vector\nb points to the same vector as a\nc points to the same vector as a and b\nd points to a different vector\n\n\na &lt;- 1:10\nb &lt;- a\nc &lt;- b\nd &lt;- 1:10\n\n# Proof\nlobstr::obj_addr(a)\n\n[1] \"0x80262c2c48\"\n\nlobstr::obj_addr(b)\n\n[1] \"0x80262c2c48\"\n\nlobstr::obj_addr(c)\n\n[1] \"0x80262c2c48\"\n\nlobstr::obj_addr(d)\n\n[1] \"0x8026369cf0\"\n\n\n\n\n\n2.2.2 Ex. 2\nThe following code accesses the mean function in multiple ways. Do they all point to the same underlying function object? Verify this with lobstr::obj_addr().\n\nmean\nbase::mean\nget(\"mean\")\nevalq(mean)\nmatch.fun(\"mean\")\n\n\nAnswer\nAll expressions above point to the same function\n\nmean %&gt;%\n  lobstr::obj_addr()\n\n[1] \"0x8018fbf7a8\"\n\nbase::mean %&gt;%\n  lobstr::obj_addr()\n\n[1] \"0x8018fbf7a8\"\n\nget(\"mean\") %&gt;%\n  lobstr::obj_addr()\n\n[1] \"0x8018fbf7a8\"\n\nevalq(mean) %&gt;%\n  lobstr::obj_addr()\n\n[1] \"0x8018fbf7a8\"\n\nmatch.fun(\"mean\") %&gt;%\n  lobstr::obj_addr()\n\n[1] \"0x8018fbf7a8\"\n\n\n\n\n\n2.2.3 Ex. 3\nBy default, base R data import functions, like read.csv(), will automatically convert non-syntactic names to syntactic ones. Why might this be problematic? What option allows you to suppress this behaviour?\n\nAnswer\nread.csv() is problematic because they by default creates syntactic names from headers. This changes data without user input.\n\n?read.csv\n\nSet check.names = FALSE to suppress this behaviour\n\n\n\n2.2.4 Ex. 4\nWhat rules does make.names() use to convert non-syntactic names into syntactic ones?\n\nAnswer\n\n?make.names\n\nThe rules for make.names() are:\n\nPrepend X if first character is invalid\nTranslate all invalid characters to .\nAppend . if name matches R keyword\nDeduplicate names\n\nThe function itself is written in C; I don’t know how to understand C yet.\n\nmake.names\n\nfunction (names, unique = FALSE, allow_ = TRUE) \n{\n    names &lt;- as.character(names)\n    names2 &lt;- .Internal(make.names(names, allow_))\n    if (unique) {\n        o &lt;- order(names != names2)\n        names2[o] &lt;- make.unique(names2[o])\n    }\n    names2\n}\n&lt;bytecode: 0x0000008017eb5310&gt;\n&lt;environment: namespace:base&gt;\n\n\n\n\n\n2.2.5 Ex. 5\nI slightly simplified the rules that govern syntactic names. Why is .123e1 not a syntactic name? Read ?make.names for the full details.\n\nAnswer\n.123e1 is not a syntactic name because the remaining text following . can be intepreted as a scientific number 123e1 = 1.23",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Names and values</span>"
    ]
  },
  {
    "objectID": "1_chapter2.html#copy-on-modify",
    "href": "1_chapter2.html#copy-on-modify",
    "title": "2  Names and values",
    "section": "2.3 Copy-on-modify",
    "text": "2.3 Copy-on-modify\n\n2.3.1 Ex. 1\nWhy is tracemem(1:10) not useful?\n\nAnswer\n\ncat(tracemem(1:10), \"\\n\")\n\n&lt;000000802792C1C8&gt; \n\ncat(tracemem(1:10), \"\\n\")\n\n&lt;0000008027962070&gt; \n\ncat(tracemem(1:10), \"\\n\")\n\n&lt;0000008027989EA8&gt; \n\ncat(tracemem(1:10), \"\\n\")\n\n&lt;000000802798AEB0&gt; \n\n\nThe purpose of tracemem() is to tag a named object and see when its underlying data structure is copied. 1:10 is not a named object, so tracemem() wouldn’t be useful.\n\n\n\n2.3.2 Ex. 2\nExplain why tracemem() shows two copies when you run this code. Hint: carefully look at the difference between this code and the code shown earlier in the section.\n\nx &lt;- c(1L, 2L, 3L)\ntracemem(x)\n\n[1] \"&lt;000000802889B408&gt;\"\n\nx[[3]] &lt;- 4\n\ntracemem[0x000000802889b408 -&gt; 0x0000008028895188]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \ntracemem[0x0000008028895188 -&gt; 0x000000802888a3c8]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n\n\n\nAnswer\ntracemem() shows two copies because x[[3]] was replaced with a double. This means the object that x points to was modified (thus copied) twice; first to coerce a integer vector to a double vector, second to replace x[[3]] with 4\n\nx &lt;- c(1L, 2L, 3L)\nlobstr::tree(x)\n\n&lt;int [3]&gt;1, 2, 3\n\nx[[3]] &lt;- 4\nlobstr::tree(x)\n\n&lt;dbl [3]&gt;1, 2, 4\n\n\n\n\n\n2.3.3 Ex. 3\nSketch out the relationship between the following objects:\n\na &lt;- 1:10\nb &lt;- list(a, a)\nc &lt;- list(b, a, 1:10)\n\n\nAnswer\nRelationship is as follows\n\na points to an ALTREP vector representing 1:10\nb is a list containing 2 references to the ALTREP vector representing 1:10\nc is a list containing a reference to b, a reference to a, and a reference to the ALTREP vector representing 1:10\n\n\ntree(a)\n\n&lt;int [10]&gt;1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n\ntree(b)\n\n&lt;list&gt;\n├─&lt;int [10]&gt;1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n└─&lt;int [10]&gt;1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n\ntree(c)\n\n&lt;list&gt;\n├─&lt;list&gt;\n│ ├─&lt;int [10]&gt;1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n│ └─&lt;int [10]&gt;1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n├─&lt;int [10]&gt;1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n└─&lt;int [10]&gt;1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n\n\n\n\n\n2.3.4 Ex. 4\nWhat happens when you run this code?\n\nx &lt;- list(1:10)\nx[[2]] &lt;- x\n\n\nAnswer\nOriginally, x is a list with a reference to the vector 1:10\nx’s underlying list is then copied-on-modify; then the 2nd slot x[[2]] is changed to contain the original list object.\nBoth list slots point to the same vector 1:10\n\n# First object\nx &lt;- list(1:10)\nstr(x)\n\nList of 1\n $ : int [1:10] 1 2 3 4 5 6 7 8 9 10\n\ntree(x)\n\n&lt;list&gt;\n└─&lt;int [10]&gt;1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n\nref(x)\n\n█ [1:0x8023c133f0] &lt;list&gt; \n└─[2:0x801a579d60] &lt;int&gt; \n\n# Second object\nx[[2]] &lt;- x\nstr(x)\n\nList of 2\n $ : int [1:10] 1 2 3 4 5 6 7 8 9 10\n $ :List of 1\n  ..$ : int [1:10] 1 2 3 4 5 6 7 8 9 10\n\ntree(x)\n\n&lt;list&gt;\n├─&lt;int [10]&gt;1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n└─&lt;list&gt;\n  └─&lt;int [10]&gt;1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n\nref(x)\n\n█ [1:0x80261a8bc8] &lt;list&gt; \n├─[2:0x801a579d60] &lt;int&gt; \n└─█ [3:0x8023c133f0] &lt;list&gt; \n  └─[2:0x801a579d60]",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Names and values</span>"
    ]
  },
  {
    "objectID": "1_chapter2.html#object-size",
    "href": "1_chapter2.html#object-size",
    "title": "2  Names and values",
    "section": "2.4 Object size",
    "text": "2.4 Object size\n\n2.4.1 Ex. 1\nIn the following example, why are object.size(y) and obj_size(y) so radically different? Consult the documentation of object.size().\n\ny &lt;- rep(list(runif(1e4)), 100)\n\nobject.size(y)\n\n8005648 bytes\n\nobj_size(y)\n\n80.90 kB\n\n\n\nAnswer\nobject.size(y) and obj_size(y) are different because object.size(y) does not take into account the degree of memory sharing in the list.\n\n\n\n2.4.2 Ex. 2\nTake the following list. Why is its size somewhat misleading?\n\nfuns &lt;- list(mean, sd, var)\nobj_size(funs)\n\n18.76 kB\n\n\n\nAnswer\nThe size are misleading because mean, sd, var are base R functions; the list does not contain exact copies, but only references. As in Ex. 1, this would be shown via object.size() and obj_size()\n\nobject.size(funs)\n\n54960 bytes\n\nobj_size(funs)\n\n18.76 kB\n\n\n\n\n\n2.4.3 Ex. 3\nPredict the output of the following code:\n\na &lt;- runif(1e6)\n\n# This will be 8MB, which is total size of a\nobj_size(a)\n\n8.00 MB\n\nb &lt;- list(a, a)\n\n# This will be 8MB, which is mostly size of a\nobj_size(b)\n\n8.00 MB\n\n# This will be 8MB, which is mostly size of a\nobj_size(a, b)\n\n8.00 MB\n\nb[[1]][[1]] &lt;- 10\n\n# This will be 16MB, which is mostly size of modified b[[1]] and\n# unmodified b[[2]] pointing to a\nobj_size(b)\n\n16.00 MB\n\n# This will be 16MB, which is mostly size of modified b[[1]] and\n# unmodified b[[2]] pointing to a\nobj_size(a, b)\n\n16.00 MB\n\nb[[2]][[1]] &lt;- 10\n\n# This will be 16MB, which is mostly size of modified b[[1]] and\n# modified b[[2]]\nobj_size(b)\n\n16.00 MB\n\n# This will be 24MB, which is mostly size of a, modified b[[1]], and\n# modified b[[2]]\nobj_size(a, b)\n\n24.00 MB",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Names and values</span>"
    ]
  },
  {
    "objectID": "1_chapter2.html#modify-in-place",
    "href": "1_chapter2.html#modify-in-place",
    "title": "2  Names and values",
    "section": "2.5 Modify-in-place",
    "text": "2.5 Modify-in-place\n\n2.5.1 Ex. 1\nExplain why the following code doesn’t create a circular list.\n\nx &lt;- list()\nx[[1]] &lt;- x\n\n\nAnswer\nBecause the 1st x refers to a different object than the 2nd x altogether. It’s not a loop. Upon the second command, a new list is created, with its first element pointing to the list behind the first x, then the new list is bound to x.\n\n# Profile the 1st x\nx &lt;- list()\nlobstr::ref(x)\n\n█ [1:0x8026439150] &lt;list&gt; \n\nlobstr::tree(x)\n\n&lt;list&gt;\n\n# Profile the 2nd x\nx[[1]] &lt;- x\nlobstr::ref(x)\n\n█ [1:0x802713d930] &lt;list&gt; \n└─█ [2:0x8026439150] &lt;list&gt; \n\nlobstr::tree(x)\n\n&lt;list&gt;\n└─&lt;list&gt;\n\n\n\n\n\n2.5.2 Ex. 2\nWrap the two methods for subtracting medians into two functions, then use the bench package to carefully compare their speeds. How does performance change as the number of columns increase?\nNB: The methods are:\n\n# Subtract median from all elements of a dataframe\nmethod_1 &lt;- function(x, medians) {\n  for (i in seq_along(medians)) {\n    x[[i]] &lt;- x[[i]] - medians[[i]]\n  }\n}\n\n# Coerce dataframe to list prior to calculation of median\nmethod_2 &lt;- function(x, medians) {\n  y &lt;- as.list(x)\n\n  for (i in seq_along(medians)) {\n    y[[i]] &lt;- y[[i]] - medians[[i]]\n  }\n}\n\n\nAnswer\nMethod 2 would be faster than method 1 since fewer copies are performed.\n\n# For the following dataframe and medians\nx &lt;- data.frame(matrix(\n  runif(5 * 1e4),\n  ncol = 5\n))\n\nmedians &lt;- vapply(\n  x,\n  median,\n  numeric(1)\n)\n\n# Compare performance\nbench::mark(\n  method_1(x, medians),\n  method_2(x, medians)\n)\n\n# A tibble: 2 × 6\n  expression                min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;           &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 method_1(x, medians)   57.1µs   62.5µs    14598.     411KB     176.\n2 method_2(x, medians)   16.3µs   19.7µs    46611.     415KB     547.\n\n\nThe 2nd method seems to be 3x faster (likely due to needing fewer copies)\n\n# For the following dataframe and medians\nx &lt;- data.frame(matrix(\n  runif(500 * 1e4),\n  ncol = 500\n))\n\nmedians &lt;- vapply(\n  x,\n  median,\n  numeric(1)\n)\n\n# Compare performance\nbench::mark(\n  method_1(x, medians),\n  method_2(x, medians)\n)\n\n# A tibble: 2 × 6\n  expression                min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;           &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 method_1(x, medians)  13.35ms  13.87ms      66.6      42MB     400.\n2 method_2(x, medians)   3.54ms   3.81ms     258.     38.2MB     816.\n\n\n\n\n\n2.5.3 Ex. 3\nWhat happens if you attempt to use tracemem() on an environment?\n\nAnswer\nExperiment:\n\nenv_test &lt;- rlang::env(\n  a = 1,\n  b = 2,\n  c = 3\n)\n\ntracemem(env_test)\n\nError in tracemem(env_test): 'tracemem' is not useful for promise and environment objects\n\n\ntracemem() will not trace it, because environments are not copied when they are modified. They are always modified in place.",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Names and values</span>"
    ]
  },
  {
    "objectID": "2_chapter3.html",
    "href": "2_chapter3.html",
    "title": "3  Vectors",
    "section": "",
    "text": "3.1 Quiz",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "2_chapter3.html#quiz",
    "href": "2_chapter3.html#quiz",
    "title": "3  Vectors",
    "section": "",
    "text": "3.1.1 Quiz 1\nWhat are the four common types of atomic vectors? What are the two rare types?\n\nAnswers\nThe 4 common types are logical, double, integer, and character\n\nlist(\n  c(TRUE, FALSE),\n  c(1.41, 5.45),\n  c(1L, 2L),\n  c(\"banana\", \"apple\")\n) %&gt;%\n  map(typeof)\n\n[[1]]\n[1] \"logical\"\n\n[[2]]\n[1] \"double\"\n\n[[3]]\n[1] \"integer\"\n\n[[4]]\n[1] \"character\"\n\n\nThe 2 rare types are complex (depicting complex numbers) and raw (binary data, displayed as hex values).\n\n# Build example complex vector\nvec_complex &lt;- complex(2)\nvec_complex[[1]] &lt;- 1\nvec_complex[[2]] &lt;- 2 + 3i\n\n# Profile it\n## Call vector directly to see complex data\nvec_complex\n\n[1] 1+0i 2+3i\n\n## Check type\nvec_complex %&gt;%\n  typeof()\n\n[1] \"complex\"\n\n\n\n# Build example raw vector\nvec_raw &lt;- raw(2)\nvec_raw[[1]] &lt;- as.raw(15)\nvec_raw[[2]] &lt;- charToRaw(\"P\")\n\n# Profile it\n## Call vector directly to see hex data\nvec_raw\n\n[1] 0f 50\n\n## Check type\nvec_raw %&gt;%\n  typeof()\n\n[1] \"raw\"\n\n## See stored data as decimal integers\nvec_raw %&gt;%\n  as.integer()\n\n[1] 15 80\n\n## Convert hex 0x50 to character\nvec_raw[[2]] %&gt;%\n  rawToChar()\n\n[1] \"P\"\n\n\n\n\n\n3.1.2 Quiz 2\nWhat are attributes? How do you get them and set them?\n\nAnswers\nAttributes are metadata attached to atomic vectors to create more complex data structures from them. For example, dim turns a vector into a matrix, names gives each vector elements a name.\nFor example:\n\nx &lt;- c(1:6)\n\n# Turn above vector into matrix (note vectors are created column-wise)\ndim(x) &lt;- c(2, 3)\nx\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n\n\n\n\n3.1.3 Quiz 3\nHow is a list different from an atomic vector? How is a matrix different from a data frame?\n\nAnswers\n\nA list is a vector of references to objects. These objects can be vectors themselves. Lists don’t contain actual “data”. Whereas vectors contain data.\nA matrix is an atomic vector with a dim attribute. A data frame is a list of atomic vectors. All data in a matrix must be the same type, where each column in a data frame may have a different type.\n\n\n\n\n3.1.4 Quiz 4\nCan you have a list that is a matrix? Can a data frame have a column that is a matrix?\n\nAnswers\nList that is a matrix: By assigning dimensions to a list:\n\nx &lt;- list(\n  c(1, 2),\n  c(3, 4),\n  c(5, 6),\n  c(7, 8)\n)\n\ndim(x) &lt;- c(2, 2)\n\nstr(x)\n\nList of 4\n $ : num [1:2] 1 2\n $ : num [1:2] 3 4\n $ : num [1:2] 5 6\n $ : num [1:2] 7 8\n - attr(*, \"dim\")= int [1:2] 2 2\n\ntree(x)\n\n&lt;list&gt;\n├─&lt;dbl [2]&gt;1, 2\n├─&lt;dbl [2]&gt;3, 4\n├─&lt;dbl [2]&gt;5, 6\n└─&lt;dbl [2]&gt;7, 8\n\nx\n\n     [,1]      [,2]     \n[1,] numeric,2 numeric,2\n[2,] numeric,2 numeric,2\n\n\nMatrix a column of a dataframe: By assigning (making sure there are enough rows):\n\nx &lt;- data.frame(\n  names = c(\"a\", \"b\", \"c\")\n)\nx$val &lt;- matrix(c(1:15), nrow = 3, ncol = 5)\n\nstr(x)\n\n'data.frame':   3 obs. of  2 variables:\n $ names: chr  \"a\" \"b\" \"c\"\n $ val  : int [1:3, 1:5] 1 2 3 4 5 6 7 8 9 10 ...\n\n# Note that rendering of this dataframe is inconsistent\nprint(x)\n\n  names val.1 val.2 val.3 val.4 val.5\n1     a     1     4     7    10    13\n2     b     2     5     8    11    14\n3     c     3     6     9    12    15\n\nreactable(x)\n\n\n\n\ndatatable(x)\n\n\n\n\ngt(x)\n\nWarning in body[[colname]][row_index] &lt;- process_text(text = vals, context =\ncontext): number of items to replace is not a multiple of replacement length\n\n\n\n\n\n\n\n\nnames\nval\n\n\n\n\na\n1\n\n\nb\n2\n\n\nc\n3\n\n\n\n\n\n\n\n\n\n\n3.1.5 Quiz 5\nHow do tibbles behave differently from data frames?\n\nAnswers\nThey don’t coerce strings to factors, print more nicely, and has more robust subsetting.",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "2_chapter3.html#atomic-vectors",
    "href": "2_chapter3.html#atomic-vectors",
    "title": "3  Vectors",
    "section": "3.2 Atomic vectors",
    "text": "3.2 Atomic vectors\n\n3.2.1 Ex. 1\nHow do you create raw and complex scalars? (See ?raw and ?complex.)\n\nAnswers\nMany ways to create raw vectors:\n\n# Create vector containing raw data\nx &lt;- c(as.raw(40), as.raw(50))\n\nx\n\n[1] 28 32\n\ntypeof(x)\n\n[1] \"raw\"\n\n# Create vector, then coerce it to raw\nx &lt;- c(40, 50) %&gt;%\n  as.raw()\n\nx\n\n[1] 28 32\n\ntypeof(x)\n\n[1] \"raw\"\n\n# Create empty raw vector then fill slots\nx &lt;- raw(2)\nx[[1]] &lt;- as.raw(40)\nx[[2]] &lt;- as.raw(50)\n\nx\n\n[1] 28 32\n\ntypeof(x)\n\n[1] \"raw\"\n\n\nMany ways to create complex vectors\n\n# Create vector containing complex data\nx &lt;- c(1 + 6i, 1.7 + 3.2i)\n\nx\n\n[1] 1.0+6.0i 1.7+3.2i\n\ntypeof(x)\n\n[1] \"complex\"\n\n# Create vector, then coerce it to complex\n## Note: no imaginary part, initially\nx &lt;- c(1, 1.7)\n\nx\n\n[1] 1.0 1.7\n\ntypeof(x)\n\n[1] \"double\"\n\nx &lt;- x %&gt;%\n  as.complex()\n\nx\n\n[1] 1.0+0i 1.7+0i\n\ntypeof(x)\n\n[1] \"complex\"\n\n# Create empty raw vector then fill slots\nx &lt;- complex(2)\nx[[1]] &lt;- 1 + 6i\nx[[2]] &lt;- 1.7 + 3.2i\n\nx\n\n[1] 1.0+6.0i 1.7+3.2i\n\ntypeof(x)\n\n[1] \"complex\"\n\n\n\n\n\n3.2.2 Ex. 2\nTest your knowledge of the vector coercion rules by predicting the output of the following uses of c():\n\nc(1, FALSE)\nc(\"a\", 1)\nc(TRUE, 1L)\n\n\nAnswers\n\n# Coerced to double\nc(1, FALSE) %&gt;%\n  typeof()\n\n[1] \"double\"\n\n# Coerced to character\nc(\"a\", 1) %&gt;%\n  typeof()\n\n[1] \"character\"\n\n# Coerced to integer\nc(TRUE, 1L) %&gt;%\n  typeof()\n\n[1] \"integer\"\n\n\n\n\n\n3.2.3 Ex. 3\nWhy is 1 == \"1\" true? Why is -1 &lt; FALSE true? Why is \"one\" &lt; 2 false?\n\nAnswers\nBecause both sides of the argument are coerced (in the order of logical - numeric - character) prior to comparison.\n\n# First comparison: Both sides coerced to character.\nc(1, \"1\") %&gt;%\n  typeof()\n\n[1] \"character\"\n\n# Second comparison: Both sides coerced to numeric\nc(-1, FALSE) %&gt;%\n  typeof()\n\n[1] \"double\"\n\nc(-1, FALSE)\n\n[1] -1  0\n\n# Third comparison: Both sides coerced to character, comparison not possible\nc(\"one\", 2) %&gt;%\n  typeof()\n\n[1] \"character\"\n\nc(\"one\", 2)\n\n[1] \"one\" \"2\"  \n\n\n\n\n\n3.2.4 Ex. 4\nWhy is the default missing value, NA, a logical vector? What’s special about logical vectors? (Hint: think about c(FALSE, NA_character_).)\n\nAnswers\nNA is automatically set to the strictest type possible, allowing it to be coerced following the rest of the vector. Where coercion is not needed, it defaults to the strictest type of logical.\n\ntypeof(NA)\n\n[1] \"logical\"\n\ntypeof(NA_integer_)\n\n[1] \"integer\"\n\n\n\n\n\n3.2.5 Ex. 5\nPrecisely what do is.atomic(), is.numeric(), and is.vector() test for?\n\nAnswers\n\nis.atomic() checks whether the object is an atomic vector (falling into 6 defined classes and direct extensions)\nis.numeric()) checks whether the data is intepretable as numbers (base type double or integer)\nis.vector() checks whether the provided vector (includes list) have no attributes other than names. Since a matrix is a vector with the dim attribute, it would fail this test.\n\n\n# Test a few scenarios\nlist(\n  list = list(),\n  matrix = matrix(\n    c(1:12),\n    nrow = 3,\n    ncol = 4\n  ),\n  logical = c(TRUE, FALSE),\n  integer = c(4L, 6L),\n  double = c(2.4, 5.2),\n  character = c(\"cook\", \"no\"),\n  factor = c(\"red\", \"blue\")\n) %&gt;%\n  map(\\(x) {\n    c(\n      is.atomic(x),\n      is.numeric(x),\n      is.vector(x)\n    )\n  })\n\n$list\n[1] FALSE FALSE  TRUE\n\n$matrix\n[1]  TRUE  TRUE FALSE\n\n$logical\n[1]  TRUE FALSE  TRUE\n\n$integer\n[1] TRUE TRUE TRUE\n\n$double\n[1] TRUE TRUE TRUE\n\n$character\n[1]  TRUE FALSE  TRUE\n\n$factor\n[1]  TRUE FALSE  TRUE",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "2_chapter3.html#attributes",
    "href": "2_chapter3.html#attributes",
    "title": "3  Vectors",
    "section": "3.3 Attributes",
    "text": "3.3 Attributes\n\n3.3.1 Ex. 1\nHow is setNames()implemented? How is unname() implemented? Read the source code.\n\nAnswers\nsetNames is simply an inline version of the names attribute setter function.\n\nsetNames\n\nfunction (object = nm, nm) \n{\n    names(object) &lt;- nm\n    object\n}\n&lt;bytecode: 0x0000008020c7ebd0&gt;\n&lt;environment: namespace:stats&gt;\n\n\nunname() is more complicated. - If the object has a names attribute, set it to NULL - If the object has a dimnames attribute, is a dataframe, and force is TRUE set it to NULL\n\nunname\n\nfunction (obj, force = FALSE) \n{\n    if (!is.null(names(obj))) \n        names(obj) &lt;- NULL\n    if (!is.null(dimnames(obj)) && (force || !is.data.frame(obj))) \n        dimnames(obj) &lt;- NULL\n    obj\n}\n&lt;bytecode: 0x000000801a6d4660&gt;\n&lt;environment: namespace:base&gt;\n\n\n\n\n\n3.3.2 Ex. 2\nWhat does dim() return when applied to a 1-dimensional vector? When might you use NROW() or NCOL()?\n\nAnswers\ndim() returns NULL when applied to a 1-dimensional vector.\n\nx &lt;- c(1, 2, 3)\ndim(x)\n\nNULL\n\n\nNROW() and NCOL() are applied to objects feasibly treated as 2-dimensional, such as vectors, matrix, dataframe. Difference between nrow() and NROW() is that NROW() treats vectors as a matrix with one column.\nThe length of the 1st dimension is the number of rows, the length of the 2nd dimension is the number of columns.\n\nx &lt;- list(\n  vector = c(1:18),\n  matrix = matrix(1:18, nrow = 6, ncol = 3),\n  array = array(1:18, dim = c(2, 3, 3))\n)\n\n# Test with nrow, ncol\nmap(x, \\(x) c(nrow(x), ncol(x)))\n\n$vector\nNULL\n\n$matrix\n[1] 6 3\n\n$array\n[1] 2 3\n\n# Test with NROW, NCOL\nmap(x, \\(x) c(NROW(x), NCOL(x)))\n\n$vector\n[1] 18  1\n\n$matrix\n[1] 6 3\n\n$array\n[1] 2 3\n\n\n\n\n\n3.3.3 Ex. 3\nHow would you describe the following three objects? What makes them different from 1:5?\n\nx1 &lt;- array(1:5, c(1, 1, 5))\nx2 &lt;- array(1:5, c(1, 5, 1))\nx3 &lt;- array(1:5, c(5, 1, 1))\nx4 &lt;- c(1:5)\n\n\nAnswers\n\nx1 is a 3D array with 1 row, 1 column, and 5 third-dimensional length\nx2 is a 3D array with 1 row, 5 columns, and 1 third-dimensional length\nx3 is a 3D array with 5 row, 1 columns, and 1 third-dimensional length\n\nThey are 3-dimensional objects with a dim attribute, whereas 1:5 does not.\n\nx &lt;- list(\n  x1,\n  x2,\n  x3,\n  x4\n)\n\nmap(x, \\(x) dim(x))\n\n[[1]]\n[1] 1 1 5\n\n[[2]]\n[1] 1 5 1\n\n[[3]]\n[1] 5 1 1\n\n[[4]]\nNULL\n\nmap(x, \\(x) str(x))\n\n int [1, 1, 1:5] 1 2 3 4 5\n int [1, 1:5, 1] 1 2 3 4 5\n int [1:5, 1, 1] 1 2 3 4 5\n int [1:5] 1 2 3 4 5\n\n\n[[1]]\nNULL\n\n[[2]]\nNULL\n\n[[3]]\nNULL\n\n[[4]]\nNULL\n\n\n\n\n\n3.3.4 Ex. 4\nAn early draft used this code to illustrate structure():\n\nstructure(1:5, comment = \"my attribute\")\n\n[1] 1 2 3 4 5\n\n\nBut when you print that object you don’t see the comment attribute. Why? Is the attribute missing, or is there something else special about it?\n\nAnswers\nBy default, the comment attribute is not printed. See ?comment\n\n# Create test object\nx &lt;- structure(1:5, comment = \"my attribute\")\n\n# Check type\ntypeof(x)\n\n[1] \"integer\"\n\n# Check attributes is assigned\nstr(attributes(x))\n\nList of 1\n $ comment: chr \"my attribute\"\n\n# Print\nprint(x)\n\n[1] 1 2 3 4 5",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "2_chapter3.html#s3-atomic-vectors",
    "href": "2_chapter3.html#s3-atomic-vectors",
    "title": "3  Vectors",
    "section": "3.4 S3 atomic vectors",
    "text": "3.4 S3 atomic vectors\n\n3.4.1 Ex. 1\nWhat sort of object does table() return? What is its type? What attributes does it have? How does the dimensionality change as you tabulate more variables?\n\nAnswers\ntable() returns a contingency table (technically an array) detailing the counts of each combinations of a factor or vector. Number of array dimensions increase as the number of variables in the contingency table increases.\n\n# Test with mtcars dataset\nmtcars %&gt;%\n  reactable(defaultPageSize = 4)\n\n\n\n\n# Create list of all contingency tables\nvars &lt;- list(\n  c(\"cyl\"),\n  c(\"cyl\", \"am\"),\n  c(\"cyl\", \"am\", \"gear\"),\n  c(\"cyl\", \"am\", \"gear\", \"carb\")\n)\n\ncontingency_tables &lt;- vars %&gt;%\n  map(\\(vars) {\n    mtcars %&gt;%\n      dplyr::select(all_of(vars)) %&gt;%\n      table()\n  })\n\n# Show dimension of all cases\nmap(\n  contingency_tables,\n  \\(x) dim(x)\n)\n\n[[1]]\n[1] 3\n\n[[2]]\n[1] 3 2\n\n[[3]]\n[1] 3 2 3\n\n[[4]]\n[1] 3 2 3 6\n\n\n\n\n\n3.4.2 Ex. 2\nWhat happens to a factor when you modify its levels?\n\nf1 &lt;- factor(letters)\nlevels(f1) &lt;- rev(levels(f1))\n\n\nAnswers\nThe underlying integer vector is unchanged, but the reversed levels attribute cause the factor to be reversed. In effect, the data is changed. So don’t use rev() for this purpose…\n\n# Profile original factor\nf1 &lt;- factor(letters)\n\nf1\n\n [1] a b c d e f g h i j k l m n o p q r s t u v w x y z\nLevels: a b c d e f g h i j k l m n o p q r s t u v w x y z\n\nas.integer(f1)\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26\n\n# Profile reversed factor\nlevels(f1) &lt;- rev(levels(f1))\n\nf1\n\n [1] z y x w v u t s r q p o n m l k j i h g f e d c b a\nLevels: z y x w v u t s r q p o n m l k j i h g f e d c b a\n\nas.integer(f1)\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26\n\n\n\n\n\n3.4.3 Ex. 3\nWhat does this code do? How do f2 and f3 differ from f1?\n\nf2 &lt;- rev(factor(letters))\nf3 &lt;- factor(letters, levels = rev(letters))\n\n\nAnswers\n\nf1: The underlying integer vector is maintained, but the factors are reversed, leading to modification of data.\nf2: The underlying integer vector is reversed, the factors are not. This represents a modification of the data.\nf3: The underlying integer vector is reversed, the factors are also reversed. Hence, the data is (in effect) unchanged.\n\n\n# Create a completely unchanged factor for reference\nf0 &lt;- factor(letters)\n\nfactors &lt;- list(\n  f0 = f0,\n  f1 = f1,\n  f2 = f2,\n  f3 = f3\n)\n\n# f1 and f2 are effectively reversed\nfactors\n\n$f0\n [1] a b c d e f g h i j k l m n o p q r s t u v w x y z\nLevels: a b c d e f g h i j k l m n o p q r s t u v w x y z\n\n$f1\n [1] z y x w v u t s r q p o n m l k j i h g f e d c b a\nLevels: z y x w v u t s r q p o n m l k j i h g f e d c b a\n\n$f2\n [1] z y x w v u t s r q p o n m l k j i h g f e d c b a\nLevels: a b c d e f g h i j k l m n o p q r s t u v w x y z\n\n$f3\n [1] a b c d e f g h i j k l m n o p q r s t u v w x y z\nLevels: z y x w v u t s r q p o n m l k j i h g f e d c b a\n\n# f2 and f3 are reversed in the integer vector\nfactors %&gt;%\n  map(as.integer)\n\n$f0\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26\n\n$f1\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26\n\n$f2\n [1] 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2\n[26]  1\n\n$f3\n [1] 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2\n[26]  1\n\n# f1 and f3 has levels reversed\nfactors %&gt;%\n  map(levels)\n\n$f0\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n$f1\n [1] \"z\" \"y\" \"x\" \"w\" \"v\" \"u\" \"t\" \"s\" \"r\" \"q\" \"p\" \"o\" \"n\" \"m\" \"l\" \"k\" \"j\" \"i\" \"h\"\n[20] \"g\" \"f\" \"e\" \"d\" \"c\" \"b\" \"a\"\n\n$f2\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n$f3\n [1] \"z\" \"y\" \"x\" \"w\" \"v\" \"u\" \"t\" \"s\" \"r\" \"q\" \"p\" \"o\" \"n\" \"m\" \"l\" \"k\" \"j\" \"i\" \"h\"\n[20] \"g\" \"f\" \"e\" \"d\" \"c\" \"b\" \"a\"",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "2_chapter3.html#lists",
    "href": "2_chapter3.html#lists",
    "title": "3  Vectors",
    "section": "3.5 Lists",
    "text": "3.5 Lists\n\n3.5.1 Ex. 1\nList all the ways that a list differs from an atomic vector.\n\nAnswers\n\nA list object does not itself contain data, only references to data objects.\nA list can contain multiple object types, even other lists. This recursiveness makes them different from vectors\n\n\n\n\n3.5.2 Ex. 2\nWhy do you need to use unlist() to convert a list to an atomic vector? Why doesn’t as.vector() work?\n\nAnswers\nA list can contain lists or other objects that do not fit inside an atomic vector. unlist() has extra logic to handle this, as.vector() doesn’t.\n\n\n\n3.5.3 Ex. 3\nCompare and contrast c() and unlist() when combining a date and date-time into a single vector.\n\nAnswers\n\n# Experiment: Set up vectors\ndate &lt;- c(\n  as.Date(\"1970-01-01\"),\n  as.Date(\"2001-09-11\")\n)\n\ndate_time &lt;- c(\n  as.POSIXct(\"2018-12-01 21:00\", tz = \"UTC\"),\n  as.POSIXct(\"2021-06-01 12:00\", tz = \"UTC\")\n)\n\na &lt;- c(date, date_time)\nb &lt;- unlist(list(date, date_time))\n\n# The original vectors are Date and POSIXct types\ndate\n\n[1] \"1970-01-01\" \"2001-09-11\"\n\ntypeof(date)\n\n[1] \"double\"\n\ndate_time\n\n[1] \"2018-12-01 21:00:00 UTC\" \"2021-06-01 12:00:00 UTC\"\n\ntypeof(date_time)\n\n[1] \"double\"\n\n# Profile a\n## a is of type Date. Coercion happened to remove time information\na\n\n[1] \"1970-01-01\" \"2001-09-11\" \"2018-12-01\" \"2021-06-01\"\n\ntypeof(a)\n\n[1] \"double\"\n\n### a contains the number of days since the epoch\nas.integer(a)\n\n[1]     0 11576 17866 18779\n\n# Profile b\n## b is of type double. All attributes were stripped from both original vectors, leaving only the numeric data behind. Elements represent days since the epoch or seconds since the epoch.\nb\n\n[1]          0      11576 1543698000 1622548800\n\ntypeof(b)\n\n[1] \"double\"",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "2_chapter3.html#data-frames-and-tibbles",
    "href": "2_chapter3.html#data-frames-and-tibbles",
    "title": "3  Vectors",
    "section": "3.6 Data frames and tibbles",
    "text": "3.6 Data frames and tibbles\n\n3.6.1 Ex. 1\nCan you have a data frame with zero rows? What about zero columns?\n\nAnswers\n\nx &lt;- data.frame()\n\nYes and yes, a dataframe can have no rows and columns. This can also occur via subsetting of dataframes.\n\nmtcars[0, 0]\n\ndata frame with 0 columns and 0 rows\n\n\n\n\n\n3.6.2 Ex. 2\nWhat happens if you attempt to set rownames that are not unique?\n\nAnswers\nWith the case of dataframes, an error is given, since each row is meant to represent an unique sample.\n\nx &lt;- mtcars[c(1:4), ]\nrownames(x) &lt;- c(\"car\", \"car\", \"bike\", \"bicycle\")\n\nWarning: non-unique value when setting 'row.names': 'car'\n\n\nError in `.rowNamesDF&lt;-`(x, value = value): duplicate 'row.names' are not allowed\n\n\n\n\n\n3.6.3 Ex. 3\nIf df is a data frame, what can you say about t(df), and t(t(df))? Perform some experiments, making sure to try different column types.\n\nAnswers\nFirst, the dataframe is coerced to a matrix. At this step, all values are coerced to the same type.\n\ngetAnywhere(t.data.frame)\n\nA single object matching 't.data.frame' was found\nIt was found in the following places\n  package:base\n  registered S3 method for t from namespace base\n  namespace:base\nwith value\n\nfunction (x) \n{\n    x &lt;- as.matrix(x)\n    NextMethod(\"t\")\n}\n&lt;bytecode: 0x000000801a111cb0&gt;\n&lt;environment: namespace:base&gt;\n\n\n\n# Experiment with diamonds\ndiamonds[1:5, ] %&gt;%\n  reactable(defaultPageSize = 4)\n\n\n\n\n# Experiment with dataframe containing list columns\ndf_experiment &lt;- tibble(\n  x = c(1, 2, 3),\n  y = list(\n    c(4, 5, 6),\n    c(7, 8, 9),\n    c(10, 11, 12)\n  )\n)\n\n\n# Transpose only numeric. Data is of type double, unchanged.\nx &lt;- diamonds[1:5, c(\"depth\", \"x\")] %&gt;%\n  t()\n\ntypeof(x)\n\n[1] \"double\"\n\nx\n\n       [,1]  [,2]  [,3] [,4]  [,5]\ndepth 61.50 59.80 56.90 62.4 63.30\nx      3.95  3.89  4.05  4.2  4.34\n\n# Transpose again. Data is of type double, unchanged.\nx &lt;- x %&gt;%\n  t()\n\ntypeof(x)\n\n[1] \"double\"\n\nx\n\n     depth    x\n[1,]  61.5 3.95\n[2,]  59.8 3.89\n[3,]  56.9 4.05\n[4,]  62.4 4.20\n[5,]  63.3 4.34\n\n# Transpose mix of numeric and factors. Data is coerced to type character.\nx &lt;- diamonds[1:5, c(\"depth\", \"color\")] %&gt;%\n  t()\n\n# Transpose again. Data is coerced to type character.\nx &lt;- x %&gt;%\n  t()\n\ntypeof(x)\n\n[1] \"character\"\n\nx\n\n     depth  color\n[1,] \"61.5\" \"E\"  \n[2,] \"59.8\" \"E\"  \n[3,] \"56.9\" \"E\"  \n[4,] \"62.4\" \"I\"  \n[5,] \"63.3\" \"J\"  \n\n# Transport df containing list-cols. df is coerced to a matrix (list with dimensions) instead.\nx &lt;- df_experiment %&gt;%\n  t()\n\ntypeof(x)\n\n[1] \"list\"\n\nx\n\n  [,1]      [,2]      [,3]     \nx 1         2         3        \ny numeric,3 numeric,3 numeric,3\n\n\n\n\n\n3.6.4 Ex. 4\nWhat does as.matrix() do when applied to a data frame with columns of different types? How does it differ from data.matrix()?\n\nAnswers\n\n# as.matrix coerces to most general type (character)\nx &lt;- as.matrix(diamonds)\ntypeof(x)\n\n[1] \"character\"\n\nx %&gt;%\n  reactable(defaultPageSize = 4)\n\n\n\n\n# data.matrix replace factor by their internal codes, then coerce to numeric.\ny &lt;- data.matrix(diamonds)\ntypeof(y)\n\n[1] \"double\"\n\ny %&gt;%\n  reactable(defaultPageSize = 4)\n\n\n\n\n# data.matrix coerces characters to factors, then do the usual replacing.\nz &lt;- diamonds %&gt;%\n  mutate(\n    cut = cut %&gt;%\n      as.character(),\n    color = color %&gt;%\n      as.character(),\n    clarity = clarity %&gt;%\n      as.character(),\n  )\n\nstr(z)\n\ntibble [53,940 × 10] (S3: tbl_df/tbl/data.frame)\n $ carat  : num [1:53940] 0.23 0.21 0.23 0.29 0.31 0.24 0.24 0.26 0.22 0.23 ...\n $ cut    : chr [1:53940] \"Ideal\" \"Premium\" \"Good\" \"Premium\" ...\n $ color  : chr [1:53940] \"E\" \"E\" \"E\" \"I\" ...\n $ clarity: chr [1:53940] \"SI2\" \"SI1\" \"VS1\" \"VS2\" ...\n $ depth  : num [1:53940] 61.5 59.8 56.9 62.4 63.3 62.8 62.3 61.9 65.1 59.4 ...\n $ table  : num [1:53940] 55 61 65 58 58 57 57 55 61 61 ...\n $ price  : int [1:53940] 326 326 327 334 335 336 336 337 337 338 ...\n $ x      : num [1:53940] 3.95 3.89 4.05 4.2 4.34 3.94 3.95 4.07 3.87 4 ...\n $ y      : num [1:53940] 3.98 3.84 4.07 4.23 4.35 3.96 3.98 4.11 3.78 4.05 ...\n $ z      : num [1:53940] 2.43 2.31 2.31 2.63 2.75 2.48 2.47 2.53 2.49 2.39 ...\n\nz &lt;- data.matrix(z)\ntypeof(z)\n\n[1] \"double\"\n\nz %&gt;%\n  reactable(defaultPageSize = 4)\n\n\n\n\n\nIn summary, as.matrix() coerces dataframes to characters, data.matrix() coerces dataframes to numeric.",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "3_chapter4.html",
    "href": "3_chapter4.html",
    "title": "4  Subsetting",
    "section": "",
    "text": "4.1 Quiz",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Subsetting</span>"
    ]
  },
  {
    "objectID": "3_chapter4.html#quiz",
    "href": "3_chapter4.html#quiz",
    "title": "4  Subsetting",
    "section": "",
    "text": "4.1.1 Quiz 1\nWhat is the result of subsetting a vector with positive integers, negative integers, a logical vector, or a character vector?\n\nAnswers\n\nPositive integer: Select elements at specified indices\n\n\nx &lt;- c(1:6)\nx[c(1, 3)]\n\n[1] 1 3\n\n\n\nNegative integers: Exclude those indices\n\n\nx &lt;- c(1:6)\nx[c(-1, -3)]\n\n[1] 2 4 5 6\n\n\n\nLogical vector: Select elements where the logical vector element is TRUE (this is how subsetting via a condition work)\n\n\n# Get even numbers (mod 2 = 0)\nx &lt;- c(1:6)\nx[x %% 2 == 0]\n\n[1] 2 4 6\n\n\n\nCharacter vector: Return elements with matching names\n\n\nx &lt;- c(1:6) %&gt;%\n  set_names(letters[1:6])\n\nx[c(\"c\", \"a\", \"d\")]\n\nc a d \n3 1 4 \n\n\n\n\n\n4.1.2 Quiz 2\nWhat’s the difference between [, [[, and $ when applied to a list?\n\nx &lt;- list(\n  a = c(1:3),\n  b = c(4:6),\n  c = c(7:9),\n  d = c(10:12)\n)\n\n\nAnswers\n\n[ Get a subsetted list based on the condition\n\n\nx[c(\"d\", \"c\")]\n\n$d\n[1] 10 11 12\n\n$c\n[1] 7 8 9\n\n\n\n[[ Get the selected list element (select via index or name)\n\n\nx[[1]]\n\n[1] 1 2 3\n\nx[[\"a\"]]\n\n[1] 1 2 3\n\n\n\nx$var Get the selected list element (select via name, shorthand for x[[\"var\"]])\n\n\nx$a\n\n[1] 1 2 3\n\n\n\n\n\n4.1.3 Quiz 3\nWhen should you use drop = FALSE?\n\nAnswers\nWhen subsetting a matrix / array / dataframe, length 1 dimensions are dropped. drop = FALSE prevents this.\n\nx &lt;- matrix(1:9, ncol = 3)\n\nx[1, ] %&gt;%\n  str() # no longer 2D\n\n int [1:3] 1 4 7\n\nx[1, , drop = FALSE] %&gt;%\n  str() # is 2D\n\n int [1, 1:3] 1 4 7\n\n\n\n\n\n4.1.4 Quiz 4\nIf x is a matrix, what does x[] &lt;- 0 do? How is it different from x &lt;- 0?\n\nAnswers\nx[] &lt;- 0 replaces all slots of the matrix with 0 but keeping its attributes. x &lt;- 0 replaces the matrix with 0.\n\n# First case\nx &lt;- matrix(1:9, ncol = 3)\nx[] &lt;- 0\nx\n\n     [,1] [,2] [,3]\n[1,]    0    0    0\n[2,]    0    0    0\n[3,]    0    0    0\n\n# Second case\nx &lt;- matrix(1:9, ncol = 3)\nx &lt;- 0\nx\n\n[1] 0\n\n\n\n\n\n4.1.5 Quiz 5\nHow can you use a named vector to relabel categorical variables?\n\nx &lt;- c(\"o\", \"e\", \"e\", \"o\", \"e\", \"o\")\nx\n\n[1] \"o\" \"e\" \"e\" \"o\" \"e\" \"o\"\n\n\n\nAnswers\n\nCreate a lookup vector, use original vector values as lookup vector names\nSubset lookup vector using original vector\n(Optional) remove lookup vector names for clarity\n\n\nlookup &lt;- c(\n  \"o\" = \"odd\",\n  \"e\" = \"even\"\n)\n\nx &lt;- lookup[x] %&gt;%\n  unname()\n\nx\n\n[1] \"odd\"  \"even\" \"even\" \"odd\"  \"even\" \"odd\"",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Subsetting</span>"
    ]
  },
  {
    "objectID": "3_chapter4.html#selecting-multiple-elements",
    "href": "3_chapter4.html#selecting-multiple-elements",
    "title": "4  Subsetting",
    "section": "4.2 Selecting multiple elements",
    "text": "4.2 Selecting multiple elements\n\n4.2.1 Ex. 1\nFix each of the following common data frame subsetting errors:\n\nmtcars[mtcars$cyl = 4, ]\nmtcars[-1:4, ]\nmtcars[mtcars$cyl &lt;= 5]\nmtcars[mtcars$cyl == 4 | 6, ]\n\n\nAnswers\n\n# Make sure the logical vector is a test\nmtcars[mtcars$cyl == 4, ] %&gt;%\n  reactable(defaultPageSize = 4)\n\n\n\n\n# Wrap indices inside a vector\nmtcars[-(1:4), ] %&gt;%\n  reactable(defaultPageSize = 4)\n\n\n\n\n# Add comma to subset rows\nmtcars[mtcars$cyl &lt;= 5, ] %&gt;%\n  reactable(defaultPageSize = 4)\n\n\n\n\n# Either use %in% or use 2 conditions\nmtcars[mtcars$cyl %in% c(4, 6), ] %&gt;%\n  reactable(defaultPageSize = 4)\n\n\n\n\nmtcars[mtcars$cyl == 4 | mtcars$cyl == 6, ] %&gt;%\n  reactable(defaultPageSize = 4)\n\n\n\n\n\n\n\n\n4.2.2 Ex. 2\nWhy does the following code yield five missing values? (Hint: why is it different from x[NA_real_]?)\n\nx &lt;- 1:5\nx[NA]\n\n[1] NA NA NA NA NA\n\n#&gt; [1] NA NA NA NA NA\n\n\nAnswers\n\nCode compares if each element of x is the same as NA; returns NA.\nNA is recycled; the check is repeated for all vector elements.\n\nNB: This is why we use is.na() to get missing values in an object instead.\n\n1L == NA\n\n[1] NA\n\n\n\n\n\n4.2.3 Ex. 3\nWhat does upper.tri() return? How does subsetting a matrix with it work? Do we need any additional subsetting rules to describe its behaviour?\n\nx &lt;- outer(1:5, 1:5, FUN = \"*\")\nx[upper.tri(x)]\n\n [1]  2  3  6  4  8 12  5 10 15 20\n\n\n\nAnswers\n\nupper.tri() returns the upper triangle (top right) portion of the matrix; where the row number is smaller than the column number.\n\n\nupper.tri(x)\n\n      [,1]  [,2]  [,3]  [,4]  [,5]\n[1,] FALSE  TRUE  TRUE  TRUE  TRUE\n[2,] FALSE FALSE  TRUE  TRUE  TRUE\n[3,] FALSE FALSE FALSE  TRUE  TRUE\n[4,] FALSE FALSE FALSE FALSE  TRUE\n[5,] FALSE FALSE FALSE FALSE FALSE\n\n\n\nThe logical matrix can be used to subset the original matrix.\nExtra behaviour includes the option to include diagonals.\nThe returned object is a vector, dropping the dim attribute of a matrix.\n\n\nx[upper.tri(x)]\n\n [1]  2  3  6  4  8 12  5 10 15 20\n\n\n\n\n\n4.2.4 Ex. 4\nWhy does mtcars[1:20] return an error? How does it differ from the similar mtcars[1:20, ]?\n\nAnswers\nmtcars[1:20] get the first 20 columns of mtcars. There are not enough columns.\n\ndim(mtcars)\n\n[1] 32 11\n\nmtcars[1:20]\n\nError in `[.data.frame`(mtcars, 1:20): undefined columns selected\n\n\nmtcars[1:20, ] gets the first 20 rows of mtcars, which is valid.\n\nmtcars[1:20, ] %&gt;%\n  reactable(defaultPageSize = 4)\n\n\n\n\n\n\n\n\n4.2.5 Ex. 5\nImplement your own function that extracts the diagonal entries from a matrix (it should behave like diag(x) where x is a matrix).\n\nAnswers\nDiagonal entries are entries where number of rows is equal to number of columns. We can programmatically create a matrix containing the relevant indices then subset the matrix for those indices.\n\nDesired behaviour\n\n# Test matrices\nx &lt;- list(\n  matrix(1:24, nrow = 3, ncol = 8),\n  matrix(1:24, nrow = 4, ncol = 6),\n  matrix(1:25, nrow = 5, ncol = 5),\n  matrix(1:24, nrow = 6, ncol = 4),\n  matrix(1:24, nrow = 8, ncol = 3)\n)\n\nmap(x, \\(x) diag(x))\n\n[[1]]\n[1] 1 5 9\n\n[[2]]\n[1]  1  6 11 16\n\n[[3]]\n[1]  1  7 13 19 25\n\n[[4]]\n[1]  1  8 15 22\n\n[[5]]\n[1]  1 10 19\n\n\n\n\nBuild function\n\nget_matrix_diagonals &lt;- function(matrix) {\n  # Get total number of diagonals in matrix\n  select_length &lt;- matrix %&gt;%\n    dim() %&gt;%\n    min()\n\n  # Build matrix identifying the diagonals\n  select &lt;-\n    c(1:select_length, 1:select_length) %&gt;%\n    matrix(\n      ncol = 2,\n      byrow = FALSE\n    )\n\n  # Filter matrix, return data\n  matrix[select] %&gt;%\n    return()\n}\n\n\n# Test behaviour\nmap(x, \\(x) get_matrix_diagonals(x))\n\n[[1]]\n[1] 1 5 9\n\n[[2]]\n[1]  1  6 11 16\n\n[[3]]\n[1]  1  7 13 19 25\n\n[[4]]\n[1]  1  8 15 22\n\n[[5]]\n[1]  1 10 19\n\n\n\n\n\n\n4.2.6 Ex. 6\nWhat does df[is.na(df)] &lt;- 0 do? How does it work?\n\nAnswers\nIt replaces NA with 0 in all dataframe cells. It creates a new logical matrix showing the status of all dataframe cells, which can then be used to subset the dataframe. The subset is then modified.\n\n# Function\nis.na.data.frame\n\nfunction (x) \n{\n    y &lt;- if (length(x)) {\n        do.call(cbind, lapply(x, is.na))\n    }\n    else matrix(FALSE, length(row.names(x)), 0)\n    if (.row_names_info(x) &gt; 0L) \n        rownames(y) &lt;- row.names(x)\n    y\n}\n&lt;bytecode: 0x000000cf6ca12740&gt;\n&lt;environment: namespace:base&gt;\n\n\n\n# Test on first 30 rows of airquality dataset\nx &lt;- airquality[1:30, ]\n\nx %&gt;%\n  reactable(defaultPageSize = 5)\n\n\n\n\nx[is.na(x)] &lt;- 0\n\nx %&gt;%\n  reactable(defaultPageSize = 5)",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Subsetting</span>"
    ]
  },
  {
    "objectID": "3_chapter4.html#selecting-a-single-element",
    "href": "3_chapter4.html#selecting-a-single-element",
    "title": "4  Subsetting",
    "section": "4.3 Selecting a single element",
    "text": "4.3 Selecting a single element\n\n4.3.1 Ex. 1\nBrainstorm as many ways as possible to extract the third value from the cyl variable in the mtcars dataset.\n\ndata(\"mtcars\")\n\n\nAnswers\n\n# Get third value in cyl variable\nmtcars$cyl[3]\n\n[1] 4\n\n# Get value of cyl variable in third row\nmtcars[3, ]$cyl\n\n[1] 4\n\n# Subset directly to variable and row\nmtcars[3, \"cyl\"]\n\n[1] 4\n\n\nNB: There are other code possible to get the same results, but the 3 main strategies are here.\n\n\n\n4.3.2 Ex. 2\nGiven a linear model, e.g., mod &lt;- lm(mpg ~ wt, data = mtcars), extract the residual degrees of freedom. Then extract the R squared from the model summary (summary(mod))\n\nmod &lt;- lm(mpg ~ wt, data = mtcars)\nmod_summary &lt;- summary(mod)\n\n\nAnswers\n\n# First, profile objects, get appropriate slots.\ntree(mod)\n\nS3&lt;lm&gt;\n├─coefficients&lt;dbl [2]&gt;: 37.285126167342, -5.34447157272268\n├─residuals&lt;dbl [32]&gt;: -2.28261064680868, -0.919770395764312, -2.08595211862542, 1.29734993896137, -0.200143957176023, -0.693254525721567, -3.90536265272207, 4.16373814964331, 2.3499592867344, 0.299856042823977, ...\n├─effects&lt;dbl [32]&gt;: -113.649737406208, -29.1157216973349, -1.66133394425873, 1.63139433490818, 0.111130494475282, -0.384004069118751, -3.60724416888595, 4.50031253940073, 2.6905816665888, 0.611130494475282, ...\n├─rank: 2\n├─fitted.values&lt;dbl [32]&gt;: 23.2826106468087, 21.9197703957643, 24.8859521186254, 20.1026500610386, 18.900143957176, 18.7932545257216, 18.2053626527221, 20.2362618503567, 20.4500407132656, 18.900143957176, ...\n├─assign&lt;int [2]&gt;: 0, 1\n├─qr: S3&lt;qr&gt;\n│ ├─qr&lt;dbl [64]&gt;: -5.65685424949238, 0.176776695296637, 0.176776695296637, 0.176776695296637, 0.176776695296637, 0.176776695296637, 0.176776695296637, 0.176776695296637, 0.176776695296637, 0.176776695296637, ...\n│ ├─qraux&lt;dbl [2]&gt;: 1.17677669529664, 1.04635439915773\n│ ├─pivot&lt;int [2]&gt;: 1, 2\n│ ├─tol: 1e-07\n│ └─rank: 2\n├─df.residual: 30\n├─xlevels: &lt;list&gt;\n├─call: &lt;language&gt; lm(formula = mpg ~ wt, data = mtcars)\n├─terms: S3&lt;terms/formula&gt; mpg ~ wt\n└─model: S3&lt;data.frame&gt;\n  ├─mpg&lt;dbl [32]&gt;: 21, 21, 22.8, 21.4, 18.7, 18.1, 14.3, 24.4, 22.8, 19.2, ...\n  └─wt&lt;dbl [32]&gt;: 2.62, 2.875, 2.32, 3.215, 3.44, 3.46, 3.57, 3.19, 3.15, 3.44, ...\n\ntree(mod_summary)\n\nS3&lt;summary.lm&gt;\n├─call: &lt;language&gt; lm(formula = mpg ~ wt, data = mtcars)\n├─terms: S3&lt;terms/formula&gt; mpg ~ wt\n├─residuals&lt;dbl [32]&gt;: -2.28261064680868, -0.919770395764312, -2.08595211862542, 1.29734993896137, -0.200143957176023, -0.693254525721567, -3.90536265272207, 4.16373814964331, 2.3499592867344, 0.299856042823977, ...\n├─coefficients&lt;dbl [8]&gt;: 37.285126167342, -5.34447157272268, 1.8776273372559, 0.559101045099323, 19.8575752640209, -9.55904414697211, 8.24179884532659e-19, 1.29395870135052e-10\n├─aliased&lt;lgl [2]&gt;: FALSE, FALSE\n├─sigma: 3.04588212478938\n├─df&lt;int [3]&gt;: 2, 30, 2\n├─r.squared: 0.752832793658264\n├─adj.r.squared: 0.744593886780206\n├─fstatistic&lt;dbl [3]&gt;: 91.3753250037617, 1, 30\n└─cov.unscaled&lt;dbl [4]&gt;: 0.38000789108422, -0.108402483824452, -0.108402483824452, 0.0336941437017492\n\n# Get residual df\nmod$df.residual\n\n[1] 30\n\n# Get R-squared\nmod_summary$r.squared\n\n[1] 0.7528328",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Subsetting</span>"
    ]
  },
  {
    "objectID": "3_chapter4.html#applications",
    "href": "3_chapter4.html#applications",
    "title": "4  Subsetting",
    "section": "4.4 Applications",
    "text": "4.4 Applications\n\n4.4.1 Ex. 1\nHow would you randomly permute the columns of a data frame? (This is an important technique in random forests.) Can you simultaneously permute the rows and columns in one step?\n\nAnswers\nFor both, get a random vector containing column and row indices then subset the dataframe accordingly.\n\n# Test on mtcars dataset\n## Permute columns\nmtcars %&gt;%\n  .[, sample(ncol(.))] %&gt;%\n  reactable(defaultPageSize = 4)\n\n\n\n\n## Permute columns and rows\nmtcars %&gt;%\n  .[sample(nrow(.)), sample(ncol(.))] %&gt;%\n  reactable(defaultPageSize = 4)\n\n\n\n\n\n\n\n\n4.4.2 Ex. 2\nHow would you select a random sample of m rows from a data frame? What if the sample had to be contiguous (i.e., with an initial row, a final row, and every row in between)?\n\nAnswers\n\nSelect sample of m rows: Sample like Ex. 1, with an extra argument to sample()\nSelect sample of m contiguous rows: Randomly select the first row index to sample from, then select rows beginning from that index.\n\n\n# Test on mtcars dataset. Let's work with 12 rows.\nm &lt;- 12\n\n## Select sample of m rows\nmtcars %&gt;%\n  .[sample(nrow(.), size = m), ] %&gt;%\n  reactable(defaultPageSize = 4)\n\n\n\n\n## Select sample of m contiguous rows\nmtcars %&gt;%\n  .[\n    sample((nrow(mtcars) - m + 1), size = 1) %&gt;%\n      seq(from = ., to = . + m - 1),\n  ] %&gt;%\n  reactable(defaultPageSize = 4)\n\n\n\n\n\n\n\n\n4.4.3 Ex. 3\nHow could you put the columns in a data frame in alphabetical order?\n\nAnswers\n\nGet vector depicting order of column names\nSubset accordingly\n\n\nmtcars %&gt;%\n  .[, order(colnames(.))] %&gt;%\n  reactable(defaultPageSize = 4)",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Subsetting</span>"
    ]
  },
  {
    "objectID": "4_chapter5.html",
    "href": "4_chapter5.html",
    "title": "5  Control flow",
    "section": "",
    "text": "5.1 Quiz",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Control flow</span>"
    ]
  },
  {
    "objectID": "4_chapter5.html#quiz",
    "href": "4_chapter5.html#quiz",
    "title": "5  Control flow",
    "section": "",
    "text": "5.1.1 Quiz 1\nWhat is the difference between if and ifelse()?\n\nAnswers\nThe difference between these conditions are: - if() operates on a single logical value - ifelse() operates on a vector of logical values. Syntax is also different.\n\n?Control\n?ifelse\n\n\n# if\nx &lt;- TRUE\nif (x) {\n  print(\"Hello\")\n}\n\n[1] \"Hello\"\n\n# ifelse\nx &lt;- c(TRUE, FALSE, TRUE, TRUE)\nifelse(\n  x,\n  print(\"Hello\"),\n  print(\"Goodbye\")\n)\n\n[1] \"Hello\"\n[1] \"Goodbye\"\n\n\n[1] \"Hello\"   \"Goodbye\" \"Hello\"   \"Hello\"  \n\n\n\n\n\n5.1.2 Quiz 2\nIn the following code, what will the value of y be if x is TRUE? What if x is FALSE? What if x is NA?\n\ny &lt;- if (x) 3\n\n\nAnswers\nOutcome of all cases are: - x &lt;- TRUE: y is assigned. - x &lt;- FALSE: y is NULL - x &lt;- NA: Error.\n\n# Let's test\n## x is TRUE\nx &lt;- TRUE\ny &lt;- if (x) 3\ny\n\n[1] 3\n\n## x is FALSE\nx &lt;- FALSE\ny &lt;- if (x) 3\ny\n\nNULL\n\n## x is NA\nx &lt;- NA\ny &lt;- if (x) 3\n\nError in if (x) 3: missing value where TRUE/FALSE needed\n\ny\n\nNULL\n\n\n\n\n\n5.1.3 Quiz 3\nWhat does switch(\"x\", x = , y = 2, z = 3) return?\n\nAnswers\nswitch evaluates the matched element or the first following non-missing argument. Since x is missing, the next argument y is evaluated, yielding 2.\n\nswitch(\"x\",\n  x = ,\n  y = 2,\n  z = 3\n)\n\n[1] 2",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Control flow</span>"
    ]
  },
  {
    "objectID": "4_chapter5.html#choices",
    "href": "4_chapter5.html#choices",
    "title": "5  Control flow",
    "section": "5.2 Choices",
    "text": "5.2 Choices\n\n5.2.1 Ex. 1\nWhat type of vector does each of the following calls to ifelse() return?\n\nifelse(TRUE, 1, \"no\")\nifelse(FALSE, 1, \"no\")\nifelse(NA, 1, \"no\")\n\n\nAnswers\n\n# Evaluates to the TRUE arg, 1\nifelse(TRUE, 1, \"no\")\n\n[1] 1\n\n# Evaluates to the FALSE arg, no\nifelse(FALSE, 1, \"no\")\n\n[1] \"no\"\n\n# NA propagates, result is NA\nifelse(NA, 1, \"no\")\n\n[1] NA\n\n\n\n\n\n5.2.2 Ex. 2\nWhy does the following code work?\n\nx &lt;- 1:10\nif (length(x)) {\n  \"not empty\"\n} else {\n  \"empty\"\n}\n\n[1] \"not empty\"\n\nx &lt;- numeric()\nif (length(x)) {\n  \"not empty\"\n} else {\n  \"empty\"\n}\n\n[1] \"empty\"\n\n\n\nAnswers\nThe code works because:\n\nFor the vector 1:10, its length is 10 and is equal to TRUE.\nFor the vector numeric(), its length is 10 and is equal to FALSE.\n\n\n# Length of x is 10, equal to TRUE\nx &lt;- 1:10\nlength(x)\n\n[1] 10\n\nlength(x) == TRUE\n\n[1] FALSE\n\n# Length of x is 0, equal to FALSE\nx &lt;- numeric()\nlength(x)\n\n[1] 0\n\nlength(x) == FALSE\n\n[1] TRUE",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Control flow</span>"
    ]
  },
  {
    "objectID": "4_chapter5.html#loops",
    "href": "4_chapter5.html#loops",
    "title": "5  Control flow",
    "section": "5.3 Loops",
    "text": "5.3 Loops\n\n5.3.1 Ex. 1\nWhy does this code succeed without errors or warnings?\n\nx &lt;- numeric()\nout &lt;- vector(\"list\", length(x))\nfor (i in 1:length(x)) {\n  out[i] &lt;- x[i]^2\n}\nout\n\n[[1]]\n[1] NA\n\n\n\nAnswers\nThis horrorshow works because:\n\nvector() by default, creates an empty vector. This behaviour is intended.\n1:length(x) is a vector counting down from 1 to 0 (c(1, 0))\n\n\n# Example case\nx1 &lt;- vector(\n  mode = \"list\",\n  length = numeric() %&gt;%\n    length()\n)\n\n# Default case\nx2 &lt;- vector(\n  mode = \"list\"\n)\n\nidentical(x1, x2)\n\n[1] TRUE\n\n\nDuring the first iteration, the following occurs:\n\nThe subsetting of x successfully returns NA as intended.\nThe out[1] list element is successfully set as intended.\n\n\nx &lt;- numeric()\nout &lt;- vector(\"list\", length(x))\n\nout[1] &lt;- x[1]^2\n\nDuring the second iteration, the following occurs:\n\nThe subsetting of x returns a zero length vector not containing any data.\nThe subsetting of out returns a zero length vector not containing any data.\nNo data accessed or modified.\n\n\nx &lt;- numeric()\nout &lt;- vector(\"list\", length(x))\n\nout[0] &lt;- x[0]^2\n\nIn summary, all operations behaved as intended by the code and contained no errors.\n\n\n\n5.3.2 Ex. 2\nWhen the following code is evaluated, what can you say about the vector being iterated?\n\nxs &lt;- c(1, 2, 3)\nfor (x in xs) {\n  xs &lt;- c(xs, x * 2)\n}\nxs\n\n[1] 1 2 3 2 4 6\n\n\n\nAnswers\nIn every iteration, the calculated value is concatenated with the previous vector and attached to the end. The for looping section is evaluated prior to beginning the loop, which ensures that the loop ends in 3 iterations, even though the length of xs is increased by the loop.\n\nxs &lt;- c(1, 2, 3)\nfor (x in xs) {\n  xs &lt;- c(xs, x * 2)\n  print(xs)\n}\n\n[1] 1 2 3 2\n[1] 1 2 3 2 4\n[1] 1 2 3 2 4 6\n\n\n\n\n\n5.3.3 Ex. 3\n\nfor (i in 1:3) {\n  i &lt;- i * 2\n  print(i)\n}\n\n[1] 2\n[1] 4\n[1] 6\n\n\n\nAnswers\nIn essence, there are two different i variables here:\n\nThe first i is outside of the loop and is responsible for counting the number of iterations (1, 2, 3)\nThe second i is inside the loop.\n\nAt every iteration, the outer i is passed in the loop, doubled, printed, then replaced with the outer i when the next iteration begins. The outer i is never modified.",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Control flow</span>"
    ]
  }
]