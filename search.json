[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Advanced R Live Workbook",
    "section": "",
    "text": "1 Introduction\nThis is my code and answers for questions in the Advanced R (2nd edition) book",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "index.html#motivation",
    "href": "index.html#motivation",
    "title": "Advanced R Live Workbook",
    "section": "1.1 Motivation",
    "text": "1.1 Motivation\nThere currently exists an amazing Advanced R Solutions book with clearly worked answers. This workbook retreads the same steps, applying what I consider to be good coding practices. The code cells run live in your browser via webR.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "1_chapter2.html",
    "href": "1_chapter2.html",
    "title": "2  Names and values",
    "section": "",
    "text": "2.1 Quiz\nMore details are available in the Names and values Quiz book chapter.",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Names and values</span>"
    ]
  },
  {
    "objectID": "1_chapter2.html#quiz",
    "href": "1_chapter2.html#quiz",
    "title": "2  Names and values",
    "section": "",
    "text": "2.1.1 Quiz 1\nGiven the following data frame, how do I create a new column called “3” that contains the sum of 1 and 2? You may only use $, not [[. What makes 1, 2, and 3 challenging as variable names?\n\n\n\n\n\n\n\n\n\nAnswer\n1 and 2 and 3 are challenging as variable names since they are non-syntactic names. Though they can still be used (here) via coercing:\n\n\n\n\n\n\n\n\n\n\n\n2.1.2 Quiz 2\nIn the following code, how much memory does y occupy?\n\n\n\n\n\n\n\n\n\nAnswer\nIn this code, y takes slightly more memory than x, but not 3 times more (only 48 bytes). This is because y is a list containing 3 references to the 1 vector underlying x. List structure takes up 48 bytes, the vector takes up 8MB.\n\n\n\n\n\n\n\n\n\n\n\n2.1.3 Quiz 3\nOn which line does a get copied in the following example?\n\n\n\n\n\n\n\n\n\nAnswer\na gets copied at line 3 of previous block b[[1]] &lt;- 10, since that is when b is modified and a new vector is created to contain data that b points to.",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Names and values</span>"
    ]
  },
  {
    "objectID": "1_chapter2.html#binding-basics",
    "href": "1_chapter2.html#binding-basics",
    "title": "2  Names and values",
    "section": "2.2 Binding basics",
    "text": "2.2 Binding basics\nMore details are available in the Names and values Binding basics book chapter.\n\n2.2.1 Ex. 1\nExplain the relationship between a, b, c, and d in the following code:\n\nAnswers\nThis can be determined using their object addresses:\n\na points to a vector\nb points to the same vector as a\nc points to the same vector as a and b\nd points to a different vector\n\n\n\n\n\n\n\n\n\n\n\n\n2.2.2 Ex. 2\nThe following code accesses the mean function in multiple ways. Do they all point to the same underlying function object? Verify this with lobstr::obj_addr().\n\n\n\n\n\n\n\n\n\nAnswer\nAll expressions above point to the same function. We can investigate using the lobstr::obj_addr() function.\n\n\n\n\n\n\n\n\n\n\n\n2.2.3 Ex. 3\nBy default, base R data import functions, like read.csv(), will automatically convert non-syntactic names to syntactic ones. Why might this be problematic? What option allows you to suppress this behaviour?\n\nAnswer\nread.csv() is problematic because they by default creates syntactic names from headers. This changes data without user input. We can suppress this behaviour by setting check.names = FALSE.\n\n\n\n\n\n\n\n\n\n\n\n2.2.4 Ex. 4\nWhat rules does make.names() use to convert non-syntactic names into syntactic ones?\n\nAnswer\n\n\n\n\n\n\n\n\nThe rules for make.names() are:\n\nPrepend X if first character is invalid\nTranslate all invalid characters to .\nAppend . if name matches R keyword\nDeduplicate names\n\nThe function itself is written in C. The accessible R function is a wrapper around the C function that allows it to be vectorised and ensures the newly formatted names are unique.\n\n\n\n\n\n\n\n\n\n\n\n2.2.5 Ex. 5\nI slightly simplified the rules that govern syntactic names. Why is .123e1 not a syntactic name? Read ?make.names for the full details.\n\nAnswer\n.123e1 is not a syntactic name because the remaining text following . can be intepreted as a scientific number 123e1 = 1.23",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Names and values</span>"
    ]
  },
  {
    "objectID": "1_chapter2.html#copy-on-modify",
    "href": "1_chapter2.html#copy-on-modify",
    "title": "2  Names and values",
    "section": "2.3 Copy-on-modify",
    "text": "2.3 Copy-on-modify\nMore details are available in the Names and values Copy-on-modify book chapter.\n\n2.3.1 Ex. 1\nWhy is tracemem(1:10) not useful?\n\nAnswer\n\n\n\n\n\n\n\n\nThe purpose of tracemem() is to tag a named object and see when its underlying data structure is copied. 1:10 is not a named object, so tracemem() wouldn’t be useful.\n(In the case of this notebook, it is not useful also because webR does not support memory profiling.)\n\n\n\n2.3.2 Ex. 2\nExplain why tracemem() shows two copies when you run this code. Hint: carefully look at the difference between this code and the code shown earlier in the section.\n\n\n\n\n\n\n\n\n\nAnswer\ntracemem() shows two copies because x[[3]] was replaced with a double. This means the object that x points to was modified (thus copied) twice; first to coerce a integer vector to a double vector, second to replace x[[3]] with 4\n\n\n\n\n\n\n\n\n\n\n\n2.3.3 Ex. 3\nSketch out the relationship between the following objects:\n\n\n\n\n\n\n\n\n\nAnswer\nThe relationship is as follows:\n\na points to an ALTREP vector representing 1:10\nb is a list containing 2 references to the ALTREP vector representing 1:10\nc is a list containing a reference to b, a reference to a, and a reference to the ALTREP vector representing 1:10\n\n\n\n\n\n\n\n\n\n\n\n\n2.3.4 Ex. 4\nWhat happens when you run this code?\n\n\n\n\n\n\n\n\n\nAnswer\n\nLine 1: Originally, x is a list with a reference to the vector 1:10\nLine 2: x’s underlying list is then copied-on-modify; then the 2nd slot x[[2]] is changed to contain the original list object. Both list slots point to the same vector 1:10",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Names and values</span>"
    ]
  },
  {
    "objectID": "1_chapter2.html#object-size",
    "href": "1_chapter2.html#object-size",
    "title": "2  Names and values",
    "section": "2.4 Object size",
    "text": "2.4 Object size\nMore details are available in the Names and values Object size book chapter.\n\n2.4.1 Ex. 1\nIn the following example, why are object.size(y) and obj_size(y) so radically different? Consult the documentation of object.size().\n\n\n\n\n\n\n\n\n\nAnswer\nobject.size(y) and obj_size(y) are different because object.size(y) does not take into account the degree of memory sharing in the list.\n\n\n\n2.4.2 Ex. 2\nTake the following list. Why is its size somewhat misleading?\n\n\n\n\n\n\n\n\n\nAnswer\nThe size are misleading because mean, sd, var are base R functions; the list does not contain exact copies, but only references to their C implementations. As in Ex. 1, this would be shown via object.size() and obj_size(). The obj_size() function includes the environment needed to run the function, which is why it is larger than object.size().\n\n\n\n\n\n\n\n\n\n\n\n2.4.3 Ex. 3\nPredict the output of the following code:\n\n\n\n\n\n\n\n\n\nAnswer\nThe object sizes are:\n\n8MB, since a refers to a vector of 1 million doubles.\n8MB, since b refers to two references to the same vector behind a.\n8MB, since the list comprising a and b refer to the same vectorbehind a.\n16MB, since b refers to two references to two different vectors; one is a copy of that behind a, and one is the original.\n16MB, since of the 3 vector references it includes, two refers to the original vector behind a, and one refers to the modified copy behind b[[1]].\n16MB, since b refers to two references to two different vectors; one is modified at step 4; one is modified at this step 6.\n24MB, since a and b now refer to three different vectors: the original vector behind a, the modified copy behind b[[1]], and the modified copy behind b[[2]].\n\n\n\n\n\n\n\n\n\n\nAn even clearer answer:\n\n\n\n\n\n\n\n\nAs shown above; objects in parts 1 - 3 refer to one vector; objects in parts 4 - 6 refer to two vectors; the object in part 7 refer to three vectors.",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Names and values</span>"
    ]
  },
  {
    "objectID": "1_chapter2.html#modify-in-place",
    "href": "1_chapter2.html#modify-in-place",
    "title": "2  Names and values",
    "section": "2.5 Modify-in-place",
    "text": "2.5 Modify-in-place\nMore details are available in the Names and values Modify-in-place book chapter.\n\n2.5.1 Ex. 1\nExplain why the following code doesn’t create a circular list.\n\n\n\n\n\n\n\n\n\nAnswer\nBecause the 1st x refers to a different object than the 2nd x altogether. Upon line 2, a new list is created, with its first element pointing to the list behind the first x, then the new list is bound to x.\n\n\n\n\n\n\n\n\n\n\n\n2.5.2 Ex. 2\nWrap the two methods for subtracting medians into two functions, then use the bench package to carefully compare their speeds. How does performance change as the number of columns increase?\nNB: The methods are:\n\n\n\n\n\n\n\n\n\nAnswer\nMethod 2 would be faster than method 1 since fewer copies are performed.\n\n\n\n\n\n\n\n\nThe 2nd method seems to be 10x faster (likely due to needing fewer copies). We can test this again on a larger dataset.\n\n\n\n\n\n\n\n\n\n\n\n2.5.3 Ex. 3\nWhat happens if you attempt to use tracemem() on an environment?\n\nAnswer\ntracemem() will not trace it, because environments are not copied when they are modified. They are always modified in place. In the context of this notebook, it will fail due to webR not supporting memory profiling.",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Names and values</span>"
    ]
  },
  {
    "objectID": "2_chapter3.html",
    "href": "2_chapter3.html",
    "title": "3  Vectors",
    "section": "",
    "text": "3.1 Quiz\nMore details are available in the Vectors Quiz book chapter.",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "2_chapter3.html#quiz",
    "href": "2_chapter3.html#quiz",
    "title": "3  Vectors",
    "section": "",
    "text": "3.1.1 Quiz 1\nWhat are the four common types of atomic vectors? What are the two rare types?\n\nAnswers\nThe 4 common types are logical, double, integer, and character\n\n\n\n\n\n\n\n\nThe 2 rare types are complex (depicting complex numbers) and raw (binary data, displayed as hex values).\n\n\n\n\n\n\n\n\n\n\n\n3.1.2 Quiz 2\nWhat are attributes? How do you get them and set them?\n\nAnswers\nAttributes are metadata attached to atomic vectors to create more complex data structures from them. For example, dim turns a vector into a matrix, names gives each vector elements a name.\nFor example:\n\n\n\n\n\n\n\n\n\n\n\n3.1.3 Quiz 3\nHow is a list different from an atomic vector? How is a matrix different from a data frame?\n\nAnswers\n\nA list is a vector of references to objects. These objects can be vectors themselves. Lists don’t contain actual “data”. Whereas atomic vectors contain data themselves.\nA matrix is an atomic vector with a dim attribute. A data frame is a list of atomic vectors. All data in a matrix must be the same type, where each column in a data frame may have a different type.\n\n\n\n\n3.1.4 Quiz 4\nCan you have a list that is a matrix? Can a data frame have a column that is a matrix?\n\nAnswers\nList that is a matrix: By assigning dimensions to a list:\n\n\n\n\n\n\n\n\nMatrix as a column of a dataframe: By assigning (making sure there are enough rows):\n\n\n\n\n\n\n\n\n\n\n\n3.1.5 Quiz 5\nHow do tibbles behave differently from data frames?\n\nAnswers\nThey don’t coerce strings to factors, print more nicely, and has more robust subsetting.",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "2_chapter3.html#atomic-vectors",
    "href": "2_chapter3.html#atomic-vectors",
    "title": "3  Vectors",
    "section": "3.2 Atomic vectors",
    "text": "3.2 Atomic vectors\nMore details are available in the Atomic vectors book chapter.\n\n3.2.1 Ex. 1\nHow do you create raw and complex scalars? (See ?raw and ?complex.)\n\nAnswers\nThere are many ways to create raw vectors:\n\n\n\n\n\n\n\n\nThere are also many ways to create complex vectors:\n\n\n\n\n\n\n\n\n\n\n\n3.2.2 Ex. 2\nTest your knowledge of the vector coercion rules by predicting the output of the following uses of c():\n\n\n\n\n\n\n\n\n\nAnswers\nIn order, these vectors will be coerced to their most basic type: - Coerced to double - Coerced to character - Coerced to integer\n\n\n\n\n\n\n\n\n\n\n\n3.2.3 Ex. 3\nWhy is 1 == \"1\" true? Why is -1 &lt; FALSE true? Why is \"one\" &lt; 2 false?\n\nAnswers\nBecause both sides of the argument are coerced (in the order of logical - numeric - character) prior to comparison.\n\n\n\n\n\n\n\n\n\n\n\n3.2.4 Ex. 4\nWhy is the default missing value, NA, a logical vector? What’s special about logical vectors? (Hint: think about c(FALSE, NA_character_).)\n\nAnswers\nNA is automatically set to the strictest type possible, allowing it to be coerced following the rest of the vector. Where coercion is not needed, it defaults to the strictest type of logical.\n\n\n\n\n\n\n\n\n\n\n\n3.2.5 Ex. 5\nPrecisely what do is.atomic(), is.numeric(), and is.vector() test for?\n\nAnswers\n\nis.atomic() checks whether the object is an atomic vector (falling into 6 defined classes and direct extensions)\nis.numeric()) checks whether the data is intepretable as numbers (base type double or integer)\nis.vector() checks whether the provided vector (includes list) have no attributes other than names. Since a matrix is a vector with the dim attribute, it would fail this test.",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "2_chapter3.html#attributes",
    "href": "2_chapter3.html#attributes",
    "title": "3  Vectors",
    "section": "3.3 Attributes",
    "text": "3.3 Attributes\nMore details are available in the Attributes book chapter.\n\n3.3.1 Ex. 1\nHow is setNames()implemented? How is unname() implemented? Read the source code.\n\nAnswers\nsetNames is simply an inline version of the names attribute setter function.\n\n\n\n\n\n\n\n\nunname() is more complicated. - If the object has a names attribute, set it to NULL - If the object has a dimnames attribute, is a dataframe, and force is TRUE set it to NULL\n\n\n\n\n\n\n\n\n\n\n\n3.3.2 Ex. 2\nWhat does dim() return when applied to a 1-dimensional vector? When might you use NROW() or NCOL()?\n\nAnswers\ndim() returns NULL when applied to a 1-dimensional vector.\n\n\n\n\n\n\n\n\nNROW() and NCOL() are applied to objects feasibly treated as 2-dimensional, such as vectors, matrix, dataframe. Difference between nrow() and NROW() is that NROW() treats vectors as a matrix with one column.\nThe length of the 1st dimension is the number of rows, the length of the 2nd dimension is the number of columns.\n\n\n\n\n\n\n\n\n\n\n\n3.3.3 Ex. 3\nHow would you describe the following three objects? What makes them different from 1:5?\n\n\n\n\n\n\n\n\n\nAnswers\n\nx1 is a 3D array with 1 row, 1 column, and 5 third-dimensional length\nx2 is a 3D array with 1 row, 5 columns, and 1 third-dimensional length\nx3 is a 3D array with 5 row, 1 columns, and 1 third-dimensional length\n\nThey are 3-dimensional objects with a dim attribute, whereas 1:5 does not.\n\n\n\n\n\n\n\n\n\n\n\n3.3.4 Ex. 4\nAn early draft used this code to illustrate structure():\n\n\n\n\n\n\n\n\nBut when you print that object you don’t see the comment attribute. Why? Is the attribute missing, or is there something else special about it?\n\nAnswers\nBy default, the comment attribute is not printed. See ?comment",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "2_chapter3.html#s3-atomic-vectors",
    "href": "2_chapter3.html#s3-atomic-vectors",
    "title": "3  Vectors",
    "section": "3.4 S3 atomic vectors",
    "text": "3.4 S3 atomic vectors\nMore details are available in the S3 atomic vectors book chapter.\n\n3.4.1 Ex. 1\nWhat sort of object does table() return? What is its type? What attributes does it have? How does the dimensionality change as you tabulate more variables?\n\nAnswers\ntable() returns a contingency table (technically an array) detailing the counts of each combinations of a factor or vector. Number of array dimensions increase as the number of variables in the contingency table increases.\n\n\n\n\n\n\n\n\n\n\n\n3.4.2 Ex. 2\nWhat happens to a factor when you modify its levels?\n\n\n\n\n\n\n\n\n\nAnswers\nThe underlying integer vector is unchanged, but the reversed levels attribute cause the factor to be reversed. In effect, the data is changed. So don’t use rev() for this purpose…\n\n\n\n\n\n\n\n\n\n\n\n3.4.3 Ex. 3\nWhat does this code do? How do f2 and f3 differ from f1?\n\n\n\n\n\n\n\n\n\nAnswers\n\nf1: The underlying integer vector is maintained, but the factors are reversed, leading to modification of data.\nf2: The underlying integer vector is reversed, the factors are not. This represents a modification of the data.\nf3: The underlying integer vector is reversed, the factors are also reversed. Hence, the data is (in effect) unchanged.",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "2_chapter3.html#lists",
    "href": "2_chapter3.html#lists",
    "title": "3  Vectors",
    "section": "3.5 Lists",
    "text": "3.5 Lists\nMore details are available in the Lists book chapter.\n\n3.5.1 Ex. 1\nList all the ways that a list differs from an atomic vector.\n\nAnswers\n\nA list object does not itself contain data, only references to data objects.\nA list can contain multiple object types, even other lists. This recursiveness makes them different from vectors\n\n\n\n\n3.5.2 Ex. 2\nWhy do you need to use unlist() to convert a list to an atomic vector? Why doesn’t as.vector() work?\n\nAnswers\nA list can contain lists or other objects that do not fit inside an atomic vector. unlist() has extra logic to handle this, as.vector() doesn’t.\n\n\n\n3.5.3 Ex. 3\nCompare and contrast c() and unlist() when combining a date and date-time into a single vector.\n\nAnswers",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "2_chapter3.html#data-frames-and-tibbles",
    "href": "2_chapter3.html#data-frames-and-tibbles",
    "title": "3  Vectors",
    "section": "3.6 Data frames and tibbles",
    "text": "3.6 Data frames and tibbles\nMore details are available in the Data frames and tibbles book chapter.\n\n3.6.1 Ex. 1\nCan you have a data frame with zero rows? What about zero columns?\n\nAnswers\n\n\n\n\n\n\n\n\nYes and yes, a dataframe can have no rows and columns. This can also occur via subsetting of dataframes.\n\n\n\n\n\n\n\n\n\n\n\n3.6.2 Ex. 2\nWhat happens if you attempt to set rownames that are not unique?\n\nAnswers\nWith the case of dataframes, an error is given, since each row is meant to represent an unique sample.\n\n\n\n\n\n\n\n\n\n\n\n3.6.3 Ex. 3\nIf df is a data frame, what can you say about t(df), and t(t(df))? Perform some experiments, making sure to try different column types.\n\nAnswers\nFirst, the dataframe is coerced to a matrix. At this step, all values are coerced to the same type.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.6.4 Ex. 4\nWhat does as.matrix() do when applied to a data frame with columns of different types? How does it differ from data.matrix()?\n\nAnswers\n\n\n\n\n\n\n\n\nIn summary, as.matrix() coerces dataframes to characters, data.matrix() coerces dataframes to numeric.",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "3_chapter4.html",
    "href": "3_chapter4.html",
    "title": "4  Subsetting",
    "section": "",
    "text": "4.1 Quiz",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Subsetting</span>"
    ]
  },
  {
    "objectID": "3_chapter4.html#quiz",
    "href": "3_chapter4.html#quiz",
    "title": "4  Subsetting",
    "section": "",
    "text": "4.1.1 Quiz 1\nWhat is the result of subsetting a vector with positive integers, negative integers, a logical vector, or a character vector?\n\nAnswers\n\nPositive integer: Select elements at specified indices\n\n\nx &lt;- c(1:6)\nx[c(1, 3)]\n\n[1] 1 3\n\n\n\nNegative integers: Exclude those indices\n\n\nx &lt;- c(1:6)\nx[c(-1, -3)]\n\n[1] 2 4 5 6\n\n\n\nLogical vector: Select elements where the logical vector element is TRUE (this is how subsetting via a condition work)\n\n\n# Get even numbers (mod 2 = 0)\nx &lt;- c(1:6)\nx[x %% 2 == 0]\n\n[1] 2 4 6\n\n\n\nCharacter vector: Return elements with matching names\n\n\nx &lt;- c(1:6) %&gt;%\n  set_names(letters[1:6])\n\nx[c(\"c\", \"a\", \"d\")]\n\nc a d \n3 1 4 \n\n\n\n\n\n4.1.2 Quiz 2\nWhat’s the difference between [, [[, and $ when applied to a list?\n\nx &lt;- list(\n  a = c(1:3),\n  b = c(4:6),\n  c = c(7:9),\n  d = c(10:12)\n)\n\n\nAnswers\n\n[ Get a subsetted list based on the condition\n\n\nx[c(\"d\", \"c\")]\n\n$d\n[1] 10 11 12\n\n$c\n[1] 7 8 9\n\n\n\n[[ Get the selected list element (select via index or name)\n\n\nx[[1]]\n\n[1] 1 2 3\n\nx[[\"a\"]]\n\n[1] 1 2 3\n\n\n\nx$var Get the selected list element (select via name, shorthand for x[[\"var\"]])\n\n\nx$a\n\n[1] 1 2 3\n\n\n\n\n\n4.1.3 Quiz 3\nWhen should you use drop = FALSE?\n\nAnswers\nWhen subsetting a matrix / array / dataframe, length 1 dimensions are dropped. drop = FALSE prevents this.\n\nx &lt;- matrix(1:9, ncol = 3)\n\nx[1, ] %&gt;%\n  str() # no longer 2D\n\n int [1:3] 1 4 7\n\nx[1, , drop = FALSE] %&gt;%\n  str() # is 2D\n\n int [1, 1:3] 1 4 7\n\n\n\n\n\n4.1.4 Quiz 4\nIf x is a matrix, what does x[] &lt;- 0 do? How is it different from x &lt;- 0?\n\nAnswers\nx[] &lt;- 0 replaces all slots of the matrix with 0 but keeping its attributes. x &lt;- 0 replaces the matrix with 0.\n\n# First case\nx &lt;- matrix(1:9, ncol = 3)\nx[] &lt;- 0\nx\n\n     [,1] [,2] [,3]\n[1,]    0    0    0\n[2,]    0    0    0\n[3,]    0    0    0\n\n# Second case\nx &lt;- matrix(1:9, ncol = 3)\nx &lt;- 0\nx\n\n[1] 0\n\n\n\n\n\n4.1.5 Quiz 5\nHow can you use a named vector to relabel categorical variables?\n\nx &lt;- c(\"o\", \"e\", \"e\", \"o\", \"e\", \"o\")\nx\n\n[1] \"o\" \"e\" \"e\" \"o\" \"e\" \"o\"\n\n\n\nAnswers\n\nCreate a lookup vector, use original vector values as lookup vector names\nSubset lookup vector using original vector\n(Optional) remove lookup vector names for clarity\n\n\nlookup &lt;- c(\n  \"o\" = \"odd\",\n  \"e\" = \"even\"\n)\n\nx &lt;- lookup[x] %&gt;%\n  unname()\n\nx\n\n[1] \"odd\"  \"even\" \"even\" \"odd\"  \"even\" \"odd\"",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Subsetting</span>"
    ]
  },
  {
    "objectID": "3_chapter4.html#selecting-multiple-elements",
    "href": "3_chapter4.html#selecting-multiple-elements",
    "title": "4  Subsetting",
    "section": "4.2 Selecting multiple elements",
    "text": "4.2 Selecting multiple elements\n\n4.2.1 Ex. 1\nFix each of the following common data frame subsetting errors:\n\nmtcars[mtcars$cyl = 4, ]\nmtcars[-1:4, ]\nmtcars[mtcars$cyl &lt;= 5]\nmtcars[mtcars$cyl == 4 | 6, ]\n\n\nAnswers\n\n# Make sure the logical vector is a test\nmtcars[mtcars$cyl == 4, ] %&gt;%\n  reactable(defaultPageSize = 4)\n\n\n\n\n# Wrap indices inside a vector\nmtcars[-(1:4), ] %&gt;%\n  reactable(defaultPageSize = 4)\n\n\n\n\n# Add comma to subset rows\nmtcars[mtcars$cyl &lt;= 5, ] %&gt;%\n  reactable(defaultPageSize = 4)\n\n\n\n\n# Either use %in% or use 2 conditions\nmtcars[mtcars$cyl %in% c(4, 6), ] %&gt;%\n  reactable(defaultPageSize = 4)\n\n\n\n\nmtcars[mtcars$cyl == 4 | mtcars$cyl == 6, ] %&gt;%\n  reactable(defaultPageSize = 4)\n\n\n\n\n\n\n\n\n4.2.2 Ex. 2\nWhy does the following code yield five missing values? (Hint: why is it different from x[NA_real_]?)\n\nx &lt;- 1:5\nx[NA]\n\n[1] NA NA NA NA NA\n\n#&gt; [1] NA NA NA NA NA\n\n\nAnswers\n\nCode compares if each element of x is the same as NA; returns NA.\nNA is recycled; the check is repeated for all vector elements.\n\nNB: This is why we use is.na() to get missing values in an object instead.\n\n1L == NA\n\n[1] NA\n\n\n\n\n\n4.2.3 Ex. 3\nWhat does upper.tri() return? How does subsetting a matrix with it work? Do we need any additional subsetting rules to describe its behaviour?\n\nx &lt;- outer(1:5, 1:5, FUN = \"*\")\nx[upper.tri(x)]\n\n [1]  2  3  6  4  8 12  5 10 15 20\n\n\n\nAnswers\n\nupper.tri() returns the upper triangle (top right) portion of the matrix; where the row number is smaller than the column number.\n\n\nupper.tri(x)\n\n      [,1]  [,2]  [,3]  [,4]  [,5]\n[1,] FALSE  TRUE  TRUE  TRUE  TRUE\n[2,] FALSE FALSE  TRUE  TRUE  TRUE\n[3,] FALSE FALSE FALSE  TRUE  TRUE\n[4,] FALSE FALSE FALSE FALSE  TRUE\n[5,] FALSE FALSE FALSE FALSE FALSE\n\n\n\nThe logical matrix can be used to subset the original matrix.\nExtra behaviour includes the option to include diagonals.\nThe returned object is a vector, dropping the dim attribute of a matrix.\n\n\nx[upper.tri(x)]\n\n [1]  2  3  6  4  8 12  5 10 15 20\n\n\n\n\n\n4.2.4 Ex. 4\nWhy does mtcars[1:20] return an error? How does it differ from the similar mtcars[1:20, ]?\n\nAnswers\nmtcars[1:20] get the first 20 columns of mtcars. There are not enough columns.\n\ndim(mtcars)\n\n[1] 32 11\n\nmtcars[1:20]\n\nError in `[.data.frame`:\n! undefined columns selected\n\n\nmtcars[1:20, ] gets the first 20 rows of mtcars, which is valid.\n\nmtcars[1:20, ] %&gt;%\n  reactable(defaultPageSize = 4)\n\n\n\n\n\n\n\n\n4.2.5 Ex. 5\nImplement your own function that extracts the diagonal entries from a matrix (it should behave like diag(x) where x is a matrix).\n\nAnswers\nDiagonal entries are entries where number of rows is equal to number of columns. We can programmatically create a matrix containing the relevant indices then subset the matrix for those indices.\n\nDesired behaviour\n\n# Test matrices\nx &lt;- list(\n  matrix(1:24, nrow = 3, ncol = 8),\n  matrix(1:24, nrow = 4, ncol = 6),\n  matrix(1:25, nrow = 5, ncol = 5),\n  matrix(1:24, nrow = 6, ncol = 4),\n  matrix(1:24, nrow = 8, ncol = 3)\n)\n\nmap(x, \\(x) diag(x))\n\n[[1]]\n[1] 1 5 9\n\n[[2]]\n[1]  1  6 11 16\n\n[[3]]\n[1]  1  7 13 19 25\n\n[[4]]\n[1]  1  8 15 22\n\n[[5]]\n[1]  1 10 19\n\n\n\n\nBuild function\n\nget_matrix_diagonals &lt;- function(matrix) {\n  # Get total number of diagonals in matrix\n  select_length &lt;- matrix %&gt;%\n    dim() %&gt;%\n    min()\n\n  # Build matrix identifying the diagonals\n  select &lt;-\n    c(1:select_length, 1:select_length) %&gt;%\n    matrix(\n      ncol = 2,\n      byrow = FALSE\n    )\n\n  # Filter matrix, return data\n  matrix[select] %&gt;%\n    return()\n}\n\n\n# Test behaviour\nmap(x, \\(x) get_matrix_diagonals(x))\n\n[[1]]\n[1] 1 5 9\n\n[[2]]\n[1]  1  6 11 16\n\n[[3]]\n[1]  1  7 13 19 25\n\n[[4]]\n[1]  1  8 15 22\n\n[[5]]\n[1]  1 10 19\n\n\n\n\n\n\n4.2.6 Ex. 6\nWhat does df[is.na(df)] &lt;- 0 do? How does it work?\n\nAnswers\nIt replaces NA with 0 in all dataframe cells. It creates a new logical matrix showing the status of all dataframe cells, which can then be used to subset the dataframe. The subset is then modified.\n\n# Function\nis.na.data.frame\n\nfunction (x) \n{\n    y &lt;- if (length(x)) {\n        do.call(cbind, lapply(x, is.na))\n    }\n    else matrix(FALSE, length(row.names(x)), 0)\n    if (.row_names_info(x) &gt; 0L) \n        rownames(y) &lt;- row.names(x)\n    y\n}\n&lt;bytecode: 0x0000008019a0c740&gt;\n&lt;environment: namespace:base&gt;\n\n\n\n# Test on first 30 rows of airquality dataset\nx &lt;- airquality[1:30, ]\n\nx %&gt;%\n  reactable(defaultPageSize = 5)\n\n\n\n\nx[is.na(x)] &lt;- 0\n\nx %&gt;%\n  reactable(defaultPageSize = 5)",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Subsetting</span>"
    ]
  },
  {
    "objectID": "3_chapter4.html#selecting-a-single-element",
    "href": "3_chapter4.html#selecting-a-single-element",
    "title": "4  Subsetting",
    "section": "4.3 Selecting a single element",
    "text": "4.3 Selecting a single element\n\n4.3.1 Ex. 1\nBrainstorm as many ways as possible to extract the third value from the cyl variable in the mtcars dataset.\n\ndata(\"mtcars\")\n\n\nAnswers\n\n# Get third value in cyl variable\nmtcars$cyl[3]\n\n[1] 4\n\n# Get value of cyl variable in third row\nmtcars[3, ]$cyl\n\n[1] 4\n\n# Subset directly to variable and row\nmtcars[3, \"cyl\"]\n\n[1] 4\n\n\nNB: There are other code possible to get the same results, but the 3 main strategies are here.\n\n\n\n4.3.2 Ex. 2\nGiven a linear model, e.g., mod &lt;- lm(mpg ~ wt, data = mtcars), extract the residual degrees of freedom. Then extract the R squared from the model summary (summary(mod))\n\nmod &lt;- lm(mpg ~ wt, data = mtcars)\nmod_summary &lt;- summary(mod)\n\n\nAnswers\n\n# First, profile objects, get appropriate slots.\ntree(mod)\n\nS3&lt;lm&gt;\n├─coefficients&lt;dbl [2]&gt;: 37.285126167342, -5.34447157272268\n├─residuals&lt;dbl [32]&gt;: -2.28261064680868, -0.919770395764312, -2.08595211862542, 1.29734993896137, -0.200143957176023, -0.693254525721567, -3.90536265272207, 4.16373814964331, 2.3499592867344, 0.299856042823977, ...\n├─effects&lt;dbl [32]&gt;: -113.649737406208, -29.1157216973349, -1.66133394425873, 1.63139433490818, 0.111130494475282, -0.384004069118751, -3.60724416888595, 4.50031253940073, 2.6905816665888, 0.611130494475282, ...\n├─rank: 2\n├─fitted.values&lt;dbl [32]&gt;: 23.2826106468087, 21.9197703957643, 24.8859521186254, 20.1026500610386, 18.900143957176, 18.7932545257216, 18.2053626527221, 20.2362618503567, 20.4500407132656, 18.900143957176, ...\n├─assign&lt;int [2]&gt;: 0, 1\n├─qr: S3&lt;qr&gt;\n│ ├─qr&lt;dbl [64]&gt;: -5.65685424949238, 0.176776695296637, 0.176776695296637, 0.176776695296637, 0.176776695296637, 0.176776695296637, 0.176776695296637, 0.176776695296637, 0.176776695296637, 0.176776695296637, ...\n│ ├─qraux&lt;dbl [2]&gt;: 1.17677669529664, 1.04635439915773\n│ ├─pivot&lt;int [2]&gt;: 1, 2\n│ ├─tol: 1e-07\n│ └─rank: 2\n├─df.residual: 30\n├─xlevels: &lt;list&gt;\n├─call: &lt;language&gt; lm(formula = mpg ~ wt, data = mtcars)\n├─terms: S3&lt;terms/formula&gt; mpg ~ wt\n└─model: S3&lt;data.frame&gt;\n  ├─mpg&lt;dbl [32]&gt;: 21, 21, 22.8, 21.4, 18.7, 18.1, 14.3, 24.4, 22.8, 19.2, ...\n  └─wt&lt;dbl [32]&gt;: 2.62, 2.875, 2.32, 3.215, 3.44, 3.46, 3.57, 3.19, 3.15, 3.44, ...\n\ntree(mod_summary)\n\nS3&lt;summary.lm&gt;\n├─call: &lt;language&gt; lm(formula = mpg ~ wt, data = mtcars)\n├─terms: S3&lt;terms/formula&gt; mpg ~ wt\n├─residuals&lt;dbl [32]&gt;: -2.28261064680868, -0.919770395764312, -2.08595211862542, 1.29734993896137, -0.200143957176023, -0.693254525721567, -3.90536265272207, 4.16373814964331, 2.3499592867344, 0.299856042823977, ...\n├─coefficients&lt;dbl [8]&gt;: 37.285126167342, -5.34447157272268, 1.8776273372559, 0.559101045099323, 19.8575752640209, -9.55904414697211, 8.24179884532659e-19, 1.29395870135052e-10\n├─aliased&lt;lgl [2]&gt;: FALSE, FALSE\n├─sigma: 3.04588212478938\n├─df&lt;int [3]&gt;: 2, 30, 2\n├─r.squared: 0.752832793658264\n├─adj.r.squared: 0.744593886780206\n├─fstatistic&lt;dbl [3]&gt;: 91.3753250037617, 1, 30\n└─cov.unscaled&lt;dbl [4]&gt;: 0.38000789108422, -0.108402483824452, -0.108402483824452, 0.0336941437017492\n\n# Get residual df\nmod$df.residual\n\n[1] 30\n\n# Get R-squared\nmod_summary$r.squared\n\n[1] 0.7528328",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Subsetting</span>"
    ]
  },
  {
    "objectID": "3_chapter4.html#applications",
    "href": "3_chapter4.html#applications",
    "title": "4  Subsetting",
    "section": "4.4 Applications",
    "text": "4.4 Applications\n\n4.4.1 Ex. 1\nHow would you randomly permute the columns of a data frame? (This is an important technique in random forests.) Can you simultaneously permute the rows and columns in one step?\n\nAnswers\nFor both, get a random vector containing column and row indices then subset the dataframe accordingly.\n\n# Test on mtcars dataset\n## Permute columns\nmtcars %&gt;%\n  .[, sample(ncol(.))] %&gt;%\n  reactable(defaultPageSize = 4)\n\n\n\n\n## Permute columns and rows\nmtcars %&gt;%\n  .[sample(nrow(.)), sample(ncol(.))] %&gt;%\n  reactable(defaultPageSize = 4)\n\n\n\n\n\n\n\n\n4.4.2 Ex. 2\nHow would you select a random sample of m rows from a data frame? What if the sample had to be contiguous (i.e., with an initial row, a final row, and every row in between)?\n\nAnswers\n\nSelect sample of m rows: Sample like Ex. 1, with an extra argument to sample()\nSelect sample of m contiguous rows: Randomly select the first row index to sample from, then select rows beginning from that index.\n\n\n# Test on mtcars dataset. Let's work with 12 rows.\nm &lt;- 12\n\n## Select sample of m rows\nmtcars %&gt;%\n  .[sample(nrow(.), size = m), ] %&gt;%\n  reactable(defaultPageSize = 4)\n\n\n\n\n## Select sample of m contiguous rows\nmtcars %&gt;%\n  .[\n    sample((nrow(mtcars) - m + 1), size = 1) %&gt;%\n      seq(from = ., to = . + m - 1),\n  ] %&gt;%\n  reactable(defaultPageSize = 4)\n\n\n\n\n\n\n\n\n4.4.3 Ex. 3\nHow could you put the columns in a data frame in alphabetical order?\n\nAnswers\n\nGet vector depicting order of column names\nSubset accordingly\n\n\nmtcars %&gt;%\n  .[, order(colnames(.))] %&gt;%\n  reactable(defaultPageSize = 4)",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Subsetting</span>"
    ]
  },
  {
    "objectID": "4_chapter5.html",
    "href": "4_chapter5.html",
    "title": "5  Control flow",
    "section": "",
    "text": "5.1 Quiz",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Control flow</span>"
    ]
  },
  {
    "objectID": "4_chapter5.html#quiz",
    "href": "4_chapter5.html#quiz",
    "title": "5  Control flow",
    "section": "",
    "text": "5.1.1 Quiz 1\nWhat is the difference between if and ifelse()?\n\nAnswers\nThe difference between these conditions are: - if() operates on a single logical value - ifelse() operates on a vector of logical values. Syntax is also different.\n\n?Control\n?ifelse\n\n\n# if\nx &lt;- TRUE\nif (x) {\n  print(\"Hello\")\n}\n\n[1] \"Hello\"\n\n# ifelse\nx &lt;- c(TRUE, FALSE, TRUE, TRUE)\nifelse(\n  x,\n  print(\"Hello\"),\n  print(\"Goodbye\")\n)\n\n[1] \"Hello\"\n[1] \"Goodbye\"\n\n\n[1] \"Hello\"   \"Goodbye\" \"Hello\"   \"Hello\"  \n\n\n\n\n\n5.1.2 Quiz 2\nIn the following code, what will the value of y be if x is TRUE? What if x is FALSE? What if x is NA?\n\ny &lt;- if (x) 3\n\n\nAnswers\nOutcome of all cases are: - x &lt;- TRUE: y is assigned. - x &lt;- FALSE: y is NULL - x &lt;- NA: Error.\n\n# Let's test\n## x is TRUE\nx &lt;- TRUE\ny &lt;- if (x) 3\ny\n\n[1] 3\n\n## x is FALSE\nx &lt;- FALSE\ny &lt;- if (x) 3\ny\n\nNULL\n\n## x is NA\nx &lt;- NA\ny &lt;- if (x) 3\n\nError in `if (x) ...`:\n! missing value where TRUE/FALSE needed\n\ny\n\nNULL\n\n\n\n\n\n5.1.3 Quiz 3\nWhat does switch(\"x\", x = , y = 2, z = 3) return?\n\nAnswers\nswitch evaluates the matched element or the first following non-missing argument. Since x is missing, the next argument y is evaluated, yielding 2.\n\nswitch(\"x\",\n  x = ,\n  y = 2,\n  z = 3\n)\n\n[1] 2",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Control flow</span>"
    ]
  },
  {
    "objectID": "4_chapter5.html#choices",
    "href": "4_chapter5.html#choices",
    "title": "5  Control flow",
    "section": "5.2 Choices",
    "text": "5.2 Choices\n\n5.2.1 Ex. 1\nWhat type of vector does each of the following calls to ifelse() return?\n\nifelse(TRUE, 1, \"no\")\nifelse(FALSE, 1, \"no\")\nifelse(NA, 1, \"no\")\n\n\nAnswers\n\n# Evaluates to the TRUE arg, 1\nifelse(TRUE, 1, \"no\")\n\n[1] 1\n\n# Evaluates to the FALSE arg, no\nifelse(FALSE, 1, \"no\")\n\n[1] \"no\"\n\n# NA propagates, result is NA\nifelse(NA, 1, \"no\")\n\n[1] NA\n\n\n\n\n\n5.2.2 Ex. 2\nWhy does the following code work?\n\nx &lt;- 1:10\nif (length(x)) {\n  \"not empty\"\n} else {\n  \"empty\"\n}\n\n[1] \"not empty\"\n\nx &lt;- numeric()\nif (length(x)) {\n  \"not empty\"\n} else {\n  \"empty\"\n}\n\n[1] \"empty\"\n\n\n\nAnswers\nThe code works because:\n\nFor the vector 1:10, its length is 10 and is equal to TRUE.\nFor the vector numeric(), its length is 10 and is equal to FALSE.\n\n\n# Length of x is 10, equal to TRUE\nx &lt;- 1:10\nlength(x)\n\n[1] 10\n\nlength(x) == TRUE\n\n[1] FALSE\n\n# Length of x is 0, equal to FALSE\nx &lt;- numeric()\nlength(x)\n\n[1] 0\n\nlength(x) == FALSE\n\n[1] TRUE",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Control flow</span>"
    ]
  },
  {
    "objectID": "4_chapter5.html#loops",
    "href": "4_chapter5.html#loops",
    "title": "5  Control flow",
    "section": "5.3 Loops",
    "text": "5.3 Loops\n\n5.3.1 Ex. 1\nWhy does this code succeed without errors or warnings?\n\nx &lt;- numeric()\nout &lt;- vector(\"list\", length(x))\nfor (i in 1:length(x)) {\n  out[i] &lt;- x[i]^2\n}\nout\n\n[[1]]\n[1] NA\n\n\n\nAnswers\nThis horrorshow works because:\n\nvector() by default, creates an empty vector. This behaviour is intended.\n1:length(x) is a vector counting down from 1 to 0 (c(1, 0))\n\n\n# Example case\nx1 &lt;- vector(\n  mode = \"list\",\n  length = numeric() %&gt;%\n    length()\n)\n\n# Default case\nx2 &lt;- vector(\n  mode = \"list\"\n)\n\nidentical(x1, x2)\n\n[1] TRUE\n\n\nDuring the first iteration, the following occurs:\n\nThe subsetting of x successfully returns NA as intended.\nThe out[1] list element is successfully set as intended.\n\n\nx &lt;- numeric()\nout &lt;- vector(\"list\", length(x))\n\nout[1] &lt;- x[1]^2\n\nDuring the second iteration, the following occurs:\n\nThe subsetting of x returns a zero length vector not containing any data.\nThe subsetting of out returns a zero length vector not containing any data.\nNo data accessed or modified.\n\n\nx &lt;- numeric()\nout &lt;- vector(\"list\", length(x))\n\nout[0] &lt;- x[0]^2\n\nIn summary, all operations behaved as intended by the code and contained no errors.\n\n\n\n5.3.2 Ex. 2\nWhen the following code is evaluated, what can you say about the vector being iterated?\n\nxs &lt;- c(1, 2, 3)\nfor (x in xs) {\n  xs &lt;- c(xs, x * 2)\n}\nxs\n\n[1] 1 2 3 2 4 6\n\n\n\nAnswers\nIn every iteration, the calculated value is concatenated with the previous vector and attached to the end. The for looping section is evaluated prior to beginning the loop, which ensures that the loop ends in 3 iterations, even though the length of xs is increased by the loop.\n\nxs &lt;- c(1, 2, 3)\nfor (x in xs) {\n  xs &lt;- c(xs, x * 2)\n  print(xs)\n}\n\n[1] 1 2 3 2\n[1] 1 2 3 2 4\n[1] 1 2 3 2 4 6\n\n\n\n\n\n5.3.3 Ex. 3\n\nfor (i in 1:3) {\n  i &lt;- i * 2\n  print(i)\n}\n\n[1] 2\n[1] 4\n[1] 6\n\n\n\nAnswers\nIn essence, there are two different i variables here:\n\nThe first i is outside of the loop and is responsible for counting the number of iterations (1, 2, 3)\nThe second i is inside the loop.\n\nAt every iteration, the outer i is passed in the loop, doubled, printed, then replaced with the outer i when the next iteration begins. The outer i is never modified.",
    "crumbs": [
      "Foundations",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Control flow</span>"
    ]
  }
]