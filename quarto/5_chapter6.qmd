# Functions {.unnumbered}

```{r setup}
#| include: FALSE

# Declare location
here::i_am("quarto/5_chapter6.qmd")

# Import packages
library("tidyverse")

# Set seed
set.seed(67)
```

# Quiz

## Quiz 1

What are the three components of a function?

### Answers

There are three components to a function:

- `formals()`: List of arguments needed to call the function
- `body()`: Logic of the function
- `environment()`: The data structure that determines how the function finds the values associated with related names.

```{r}
formals(str_c)

body(str_c)

environment(str_c)
```

## Quiz 2

What does the following code return?

```{r}
x <- 10
f1 <- function(x) {
  function() {
    x + 10
  }
}
f1(1)()
```

### Answers

The above code works as below

- `x` is passed from the global environment to the environment of the outer function
- `x` is then passed to the inner function (no arguments)
- `x + 10` (in this case `11`) then returned

## Quiz 3

How would you usually write this code?

```{r}
`+`(1, `*`(2, 3))
```

### Answers

It would be written like this:

```{r}
1 + (2 * 3)
```

## Quiz 4

How could you make this call easier to read?

```{r}
mean(, TRUE, x = c(1:10, NA))
```

### Answers

## Quiz 5

Does the following code throw an error when executed? Why or why not?

```{r}
f2 <- function(a, b) {
  a * 10
}
f2(10, stop("This is an error!"))
```

### Answers

## Quiz 6

What is an infix function? How do you write it? What’s a replacement function? How do you write it?

### Answers

## Quiz 7

How do you ensure that cleanup action occurs regardless of how a function exits?

### Answers

# Function fundamentals

## Ex. 1

Given a name, like "mean", `match.fun()` lets you find a function. Given a function, can you find its name? Why doesn’t that make sense in R?

### Answers

## Ex. 2

It’s possible (although typically not useful) to call an anonymous function. Which of the two approaches below is correct? Why?

```{r}
function(x) 3()
(function(x) 3)()
```

### Answers

## Ex. 3

A good rule of thumb is that an anonymous function should fit on one line and shouldn’t need to use {}. Review your code. Where could you have used an anonymous function instead of a named function? Where should you have used a named function instead of an anonymous function?

### Answers

## Ex. 4

What function allows you to tell if an object is a function? What function allows you to tell if a function is a primitive function?

### Answers

## Ex. 5

This code makes a list of all functions in the base package.
Use it to answer the following questions:

a. Which base function has the most arguments?

b. How many base functions have no arguments? What’s special about those functions?

c. How could you adapt the code to find all primitive functions?

```{r}
objs <- mget(ls("package:base", all = TRUE), inherits = TRUE)
funs <- Filter(is.function, objs)
```

### Answers

## Ex. 6

What are the three important components of a function?

### Answers

## Ex. 7

When does printing a function not show the environment it was created in?

### Answers

# Lexical scoping

## Ex. 1

What does the following code return? Why? Describe how each of the three c’s is interpreted.

```{r}
c <- 10
c(c = c)
```

### Answers

## Ex. 2

What are the four principles that govern how R looks for values?

### Answers

## Ex. 3

What does the following function return? Make a prediction before running the code yourself.

### Answers

```{r}
#| eval: FALSE
f <- function(x) {
  f <- function(x) {
    f <- function() {
      x^2
    }
    f() + 1
  }
  f(x) * 2
}
f(10)
```

# Lazy evaluation

## Ex. 1

What important property of && makes x_ok() work?

```{r}
x_ok <- function(x) {
  !is.null(x) && length(x) == 1 && x > 0
}

x_ok(NULL)
x_ok(1)
x_ok(1:3)
```

What is different with this code? Why is this behaviour undesirable here?

```{r}
x_ok <- function(x) {
  !is.null(x) & length(x) == 1 & x > 0
}

x_ok(NULL)
x_ok(1)
x_ok(1:3)
```

### Answers

## Ex. 2

What does this function return? Why? Which principle does it illustrate?

### Answers

```{r}
f2 <- function(x = z) {
  z <- 100
  x
}
f2()
```

## Ex. 3

What does this function return? Why? Which principle does it illustrate?

```{r}
y <- 10
f1 <- function(
  x = {
    y <- 1
    2
  },
  y = 0
) {
  c(x, y)
}
f1()
y
```

### Answers

## Ex. 4

In `hist()`, the default value of `xlim` is `range(breaks)`, the default value for breaks is `"Sturges"`, and the value for `range("Sturges")` is

```{r}
range("Sturges")
```

Explain how `hist()` works to get a correct `xlim` value.

### Answers

## Ex. 5

Explain why this function works. Why is it confusing?

```{r}
show_time <- function(x = stop("Error!")) {
  stop <- function(...) Sys.time()
  print(x)
}
show_time()
#> [1] "2025-03-13 02:13:34 UTC"
```

### Answers

## Ex. 6

How many arguments are required when calling `library()`?

### Answers

# `...` (dot-dot-dot)

## Ex. 1

Explain the following results:

```{r}
sum(1, 2, 3)
mean(1, 2, 3)

sum(1, 2, 3, na.omit = TRUE)
mean(1, 2, 3, na.omit = TRUE)
```

### Answers

## Ex. 2

Explain how to find the documentation for the named arguments in the following function call:

```{r}
plot(1:10, col = "red", pch = 20, xlab = "x", col.lab = "blue")
```

### Answers

## Ex. 3

Why does `plot(1:10, col = "red")` only colour the points, not the axes or labels? Read the source code of `plot.default()` to find out.

### Answers

# Exiting a function

## Ex. 1

What does `load()` return? Why don’t you normally see these values?

### Answers

## Ex. 2

What does `write.table()` return? What would be more useful?

### Answers

## Ex. 3

How does the `chdir` parameter of `source()` compare to `with_dir()`? Why might you prefer one to the other?

### Answers

## Ex. 4

Write a function that opens a graphics device, runs the supplied code, and closes the graphics device (always, regardless of whether or not the plotting code works).

### Answers

## Ex. 5

We can use `on.exit()` to implement a simple version of `capture.output()`.

```{r}
capture.output2 <- function(code) {
  temp <- tempfile()
  on.exit(file.remove(temp), add = TRUE, after = TRUE)

  sink(temp)
  on.exit(sink(), add = TRUE, after = TRUE)

  force(code)
  readLines(temp)
}
capture.output2(cat("a", "b", "c", sep = "\n"))
```

Compare `capture.output()` to `capture.output2()`. How do the functions differ? What features have I removed to make the key ideas easier to see? How have I rewritten the key ideas so they’re easier to understand?

### Answers

# Function forms

## Ex. 1

Rewrite the following code snippets into prefix form:

```{r}
1 + 2 + 3

1 + (2 + 3)

if (length(x) <= 5) {
  x[[5]]
} else {
  x[[n]]
}
```

### Answers

## Ex. 2

Clarify the following list of odd function calls:

```{r}
x <- sample(replace = TRUE, 20, x = c(1:10, NA))
y <- runif(min = 0, max = 1, 20)
cor(m = "k", y = y, u = "p", x = x)
```

### Answers

## Ex. 3

Explain why the following code fails:

```{r}
#| error: TRUE
modify(get("x"), 1) <- 10
```

### Answers

## Ex. 4

Create a replacement function that modifies a random location in a vector.

### Answers

## Ex. 5

Write your own version of + that pastes its inputs together if they are character vectors but behaves as usual otherwise. In other words, make this code work:

```{r}
#| eval: FALSE
1 + 2
#> [1] 3

"a" + "b"
#> [1] "ab"
```

### Answers

## Ex. 6

Create a list of all the replacement functions found in the base package. Which ones are primitive functions? (Hint: use `apropos()`.)

### Answers

## Ex. 7

What are valid names for user-created infix functions?

### Answers

## Ex. 8

Create an infix `xor()` operator.

### Answers

## Ex. 9

Create infix versions of the set functions `intersect()`, `union()`, and `setdiff()`. You might call them `%n%`, `%u%`, and `%/%` to match conventions from mathematics.

### Answers