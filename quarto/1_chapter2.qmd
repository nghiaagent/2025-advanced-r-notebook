---
format: live-html
webr:
  packages:
    - bench
    - here
    - lobstr
    - reactable
    - tidyverse
---

{{< include ./_extensions/r-wasm/live/_knitr.qmd >}}

# Names and values

```{webr setup}
#| include: FALSE
#| edit: false
# Declare location
here::i_am("quarto/1_chapter2.qmd")

# Set seed
set.seed(67)
```

## Quiz

More details are available in the [Names and values Quiz](https://adv-r.hadley.nz/names-values.html#quiz) book chapter.

### Quiz 1

Given the following data frame, how do I create a new column called "3" that contains the sum of 1 and 2? You may only use `$`, not `[[`. What makes 1, 2, and 3 challenging as variable names?

```{webr Quiz 1 Q}
#| edit: false
df <- data.frame(runif(3), runif(3))
names(df) <- c(1, 2)
```

#### Answer

`1` and `2` and `3` are challenging as variable names since they are non-syntactic names. Though they can still be used (here) via coercing:

```{webr Quiz 1 A}
#| autorun: true
# Build object for question
df <- data.frame(runif(3), runif(3))
names(df) <- c(1, 2)

# Solution
df$`3` <- df$`1` + df$`2`
head(df)
```

### Quiz 2

In the following code, how much memory does y occupy?

```{webr Quiz 2 Q}
#| edit: false
x <- runif(1e6)
y <- list(x, x, x)
```

#### Answer

In this code, y takes slightly more memory than x, but not 3 times more (only 48 bytes). This is because y is a list containing 3 references to the 1 vector underlying x. List structure takes up 48 bytes, the vector takes up 8MB.

```{webr Quiz 2 A}
#| autorun: true
# Build object for quiz
x <- runif(1e6)
y <- list(x, x, x)

# Quiz answers
message("Size of x: ")
lobstr::obj_size(x)

message("Size of y: ")
lobstr::obj_size(y)

message("Difference in size: ")
lobstr::obj_size(y) - lobstr::obj_size(x)
```

### Quiz 3

On which line does `a` get copied in the following example?

```{webr Quiz 3 Q}
#| edit: false
a <- c(1, 5, 3, 2)
b <- a
b[[1]] <- 10
```

#### Answer

`a` gets copied at line 3 of previous block `b[[1]] <- 10`, since that is when `b` is modified and a new vector is created to contain data that b points to.

## Binding basics

More details are available in the [Names and values Binding basics](https://adv-r.hadley.nz/names-values.html#binding-basics) book chapter.

### Ex. 1

Explain the relationship between `a`, `b`, `c`, and `d` in the following code:

#### Answers

This can be determined using their object addresses:  

- `a` points to a vector
- `b` points to the same vector as `a`
- `c` points to the same vector as `a` and `b`
- `d` points to a different vector

```{webr Ex 2.2.1}
#| autorun: true
# Build objects for question
a <- 1:10
b <- a
c <- b
d <- 1:10

# Perform proof
message("Address of a: ")
lobstr::obj_addr(a)

message("Address of b: ")
lobstr::obj_addr(b)

message("Address of c: ")
lobstr::obj_addr(c)

message("Address of d: ")
lobstr::obj_addr(d)

```

### Ex. 2

The following code accesses the `mean` function in multiple ways. Do they all point to the same underlying function object? Verify this with `lobstr::obj_addr()`.

```{webr Ex 2.2.2 Q}
#| eval: false
mean
base::mean
get("mean")
evalq(mean)
match.fun("mean")
```

#### Answer

All expressions above point to the same function. We can investigate using the `lobstr::obj_addr()` function.

```{webr Ex 2.2.2 A}
#| autorun: true
message("Address of mean: ")
mean |>
  lobstr::obj_addr()

message("Address of base::mean: ")
base::mean |>
  lobstr::obj_addr()

message("Address of get(\"mean\"): ")
get("mean") |>
  lobstr::obj_addr()

message("Address of evalq(mean): ")
evalq(mean) |>
  lobstr::obj_addr()

message("Address of match.fun(\"mean\"): ")
match.fun("mean") |>
  lobstr::obj_addr()
```

### Ex. 3

By default, base R data import functions, like `read.csv()`, will automatically convert non-syntactic names to syntactic ones. Why might this be problematic? What option allows you to suppress this behaviour?

#### Answer

`read.csv()` is problematic because they by default creates syntactic names from headers. This changes data without user input. We can suppress this behaviour by setting `check.names = FALSE`.

```{webr Ex 2.2.3 Q}
#| eval: false
?read.csv
```


### Ex. 4

What rules does `make.names()` use to convert non-syntactic names into syntactic ones?

#### Answer

```{webr Ex 2.2.4 Q}
#| eval: false
?make.names
```

The rules for `make.names()` are:

- Prepend `X` if first character is invalid
- Translate all invalid characters to `.`
- Append `.` if name matches R keyword
- Deduplicate names

The function itself is written in `C`. The accessible R function is a wrapper around the C function that allows it to be vectorised and ensures the newly formatted names are unique.

```{webr Ex 2.2.4 A}
#| autorun: true
make.names
```

### Ex. 5

I slightly simplified the rules that govern syntactic names. Why is `.123e1` not a syntactic name? Read `?make.names` for the full details.

#### Answer

`.123e1` is not a syntactic name because the remaining text following `.` can be intepreted as a scientific number `123e1 = 1.23`

## Copy-on-modify

More details are available in the [Names and values Copy-on-modify](https://adv-r.hadley.nz/names-values.html#copy-on-modify) book chapter.


### Ex. 1

Why is `tracemem(1:10)` not useful?

#### Answer

```{webr Ex 2.2.5 A}
#| autorun: true
cat(tracemem(1:10), "\n")
cat(tracemem(1:10), "\n")
cat(tracemem(1:10), "\n")
cat(tracemem(1:10), "\n")
```

The purpose of `tracemem()` is to tag a named object and see when its underlying data structure is copied. `1:10` is not a named object, so `tracemem()` wouldn't be useful.

(In the case of this notebook, it is not useful also because webR does not support memory profiling.)

### Ex. 2

Explain why `tracemem()` shows two copies when you run this code. Hint: carefully look at the difference between this code and the code shown earlier in the section.

```{webr Ex 2.2.6 Q}
#| eval: false
x <- c(1L, 2L, 3L)
tracemem(x)

x[[3]] <- 4
```

#### Answer

`tracemem()` shows two copies because `x[[3]]` was replaced with a double. This means the object that x points to was modified (thus copied) twice; first to coerce a integer vector to a double vector, second to replace `x[[3]]` with `4`

```{webr Ex 2.2.6 A}
#| autorun: true
message("Initial object: ")
x <- c(1L, 2L, 3L)
lobstr::tree(x)

message("After modification: ")
x[[3]] <- 4
lobstr::tree(x)
```

### Ex. 3

Sketch out the relationship between the following objects:

```{webr Ex 2.2.7 Q}
#| eval: false
a <- 1:10
b <- list(a, a)
c <- list(b, a, 1:10)
```

#### Answer

The relationship is as follows:

-   `a` points to an ALTREP vector representing `1:10`
-   `b` is a list containing 2 references to the ALTREP vector representing `1:10`
-   `c` is a list containing a reference to `b`, a reference to `a`, and a reference to the ALTREP vector representing `1:10`

```{webr Ex 2.2.7 A}
#| autorun: true
# Build objects for question
a <- 1:10
b <- list(a, a)
c <- list(b, a, 1:10)

# Perform proof
message("Showing relationship of a")
lobstr::tree(a)

message("Showing relationship of b")
lobstr::tree(b)

message("Showing relationship of c")
lobstr::tree(c)
```

### Ex. 4

What happens when you run this code?

```{webr Ex 2.2.8 Q}
#| eval: false
x <- list(1:10)
x[[2]] <- x
```

#### Answer

- Line 1: Originally, `x` is a list with a reference to the vector `1:10`
- Line 2: `x`'s underlying list is then copied-on-modify; then the 2nd slot `x[[2]]` is changed to contain the original list object. Both list slots point to the same vector `1:10`

```{webr Ex 2.2.8 A1}
#| autorun: true
# First object
message("Initial object: ")
x <- list(1:10)
str(x)
lobstr::tree(x)
lobstr::ref(x)

# Second object
message("After modification: ")
x <- list(1:10)
x[[2]] <- x
str(x)
lobstr::tree(x)
lobstr::ref(x)
```

## Object size

More details are available in the [Names and values Object size](https://adv-r.hadley.nz/names-values.html#object-size) book chapter.

### Ex. 1

In the following example, why are `object.size(y)` and `obj_size(y)` so radically different? Consult the documentation of `object.size()`.

```{webr Ex 2.2.9 A}
#| autorun: true
y <- rep(list(runif(1e4)), 100)
object.size(y)
lobstr::obj_size(y)
```

#### Answer

`object.size(y)` and `obj_size(y)` are different because `object.size(y)` does not take into account the degree of memory sharing in the list.

### Ex. 2

Take the following list. Why is its size somewhat misleading?

```{webr Ex 2.2.10 Q}
#| eval: false
funs <- list(mean, sd, var)
lobstr::obj_size(funs)
```

#### Answer

The size are misleading because `mean`, `sd`, `var` are base R functions; the list does not contain exact copies, but only references to their `C` implementations. As in Ex. 1, this would be shown via `object.size()` and `obj_size()`. The `obj_size()` function includes the environment needed to run the function, which is why it is larger than `object.size()`.

```{webr Ex 2.2.10 A}
#| autorun: true
# Build objects for question
funs <- list(mean, sd, var)

# Perform proof
object.size(funs)
lobstr::obj_size(funs)
```

### Ex. 3

Predict the output of the following code:

```{webr Ex 2.2.11 Q}
#| eval: false
# Part 1
a <- runif(1e6)
lobstr::obj_size(a)

# Part 2
b <- list(a, a)
lobstr::obj_size(b)

# Part 3
lobstr::obj_size(a, b)

# Part 4
b[[1]][[1]] <- 10
lobstr::obj_size(b)

# Part 5
lobstr::obj_size(a, b)

# Part 6
b[[2]][[1]] <- 10
lobstr::obj_size(b)

# Part 7
lobstr::obj_size(a, b)

```

#### Answer

The object sizes are:

1. `8MB`, since `a` refers to a vector of 1 million doubles.
2. `8MB`, since `b` refers to two references to the same vector behind `a`.
3. `8MB`, since the list comprising `a` and `b` refer to the same vectorbehind `a`.
4. `16MB`, since `b` refers to two references to two different vectors; one is a copy of that behind `a`, and one is the original.
5. `16MB`, since of the 3 vector references it includes, two refers to the original vector behind `a`, and one refers to the modified copy behind `b[[1]]`.
6. `16MB`, since `b` refers to two references to two different vectors; one is modified at step 4; one is modified at this step 6.
7. `24MB`, since `a` and `b` now refer to three different vectors: the original vector behind `a`, the modified copy behind `b[[1]]`, and the modified copy behind `b[[2]]`.

```{webr Ex 2.2.11 A1}
#| autorun: true
# Part 1
a <- runif(1e6)
message("Size of a: ")
lobstr::obj_size(a)

# Part 2
b <- list(a, a)
message("Size of b: ")
lobstr::obj_size(b)

# Part 3
message("Size of a and b: ")
lobstr::obj_size(a, b)

# Part 4
b[[1]][[1]] <- 10
message("Size of b after modification: ")
lobstr::obj_size(b)

# Part 5
message("Size of a and b: ")
lobstr::obj_size(a, b)

# Part 6
b[[2]][[1]] <- 10
message("Size of b after modification: ")
lobstr::obj_size(b)

# Part 7
message("Size of a and b: ")
lobstr::obj_size(a, b)
```

##### An even clearer answer:

```{webr Ex 2.2.11 A2}
#| autorun: true
# Part 1
a <- runif(1e6)
message("References of a: ")
lobstr::ref(a)

# Part 2
b <- list(a, a)
message("References of b: ")
lobstr::ref(b)

# Part 3
message("References of a and b: ")
lobstr::ref(a, b)

# Part 4
b[[1]][[1]] <- 10
message("References of b after modification: ")
lobstr::ref(b)

# Part 5
message("References of a and b: ")
lobstr::ref(a, b)

# Part 6
b[[2]][[1]] <- 10
message("References of b after modification: ")
lobstr::ref(b)

# Part 7
message("References of a and b: ")
lobstr::ref(a, b)
```

As shown above; objects in parts 1 - 3 refer to one vector; objects in parts 4 - 6 refer to two vectors; the object in part 7 refer to three vectors.

## Modify-in-place

More details are available in the [Names and values Modify-in-place](https://adv-r.hadley.nz/names-values.html#modify-in-place) book chapter.

### Ex. 1

Explain why the following code doesnâ€™t create a circular list.

```{webr Ex 2.3.1 Q}
#| eval: false
x <- list()
x[[1]] <- x
```

#### Answer

Because the 1st `x` refers to a different object than the 2nd `x` altogether. Upon line 2, a new list is created, with its first element pointing to the list behind the first `x`, then the new list is bound to `x`.

```{webr Ex 2.3.1 A}
#| autorun: true
# Profile the 1st x
message("Initial object: ")
x <- list()
lobstr::ref(x)
lobstr::tree(x)

# Profile the 2nd x
message("After modification: ")
x[[1]] <- x
lobstr::ref(x)
lobstr::tree(x)
```

### Ex. 2

Wrap the two methods for subtracting medians into two functions, then use the `bench` package to carefully compare their speeds. How does performance change as the number of columns increase?

**NB:** The methods are:

```{webr Ex 2.3.2 Q}
#| eval: false
# Subtract median from all elements of a dataframe
method_1 <- function(x, medians) {
  for (i in seq_along(medians)) {
    x[[i]] <- x[[i]] - medians[[i]]
  }
}

# Coerce dataframe to list prior to calculation of median
method_2 <- function(x, medians) {
  y <- as.list(x)

  for (i in seq_along(medians)) {
    y[[i]] <- y[[i]] - medians[[i]]
  }
}
```

#### Answer

Method 2 would be faster than method 1 since fewer copies are performed.

```{webr Ex 2.3.2 A1}
#| autorun: true
# Build objects for question
## Example functions
### Subtract median from all elements of a dataframe
method_1 <- function(x, medians) {
  for (i in seq_along(medians)) {
    x[[i]] <- x[[i]] - medians[[i]]
  }
}

### Coerce dataframe to list prior to calculation of median
method_2 <- function(x, medians) {
  y <- as.list(x)

  for (i in seq_along(medians)) {
    y[[i]] <- y[[i]] - medians[[i]]
  }
}

## Example data
x <- data.frame(matrix(
  runif(5 * 1e4),
  ncol = 5
))

medians <- vapply(x, median, numeric(1))

# Perform proof
## NB: This would be performed live in your browser!
results <- bench::mark(
  method_1(x, medians),
  method_2(x, medians)
)

print(results)

message(paste(
  "Method 2 is ",
  results$`itr/sec`[2] / results$`itr/sec`[1],
  " times faster than method 1"
))
```

The 2nd method seems to be 10x faster (likely due to needing fewer copies). We can test this again on a larger dataset.

```{webr Ex 2.3.2 A2}
#| autorun: true
# Build objects for question
## Example functions
### Subtract median from all elements of a dataframe
method_1 <- function(x, medians) {
  for (i in seq_along(medians)) {
    x[[i]] <- x[[i]] - medians[[i]]
  }
}

### Coerce dataframe to list prior to calculation of median
method_2 <- function(x, medians) {
  y <- as.list(x)

  for (i in seq_along(medians)) {
    y[[i]] <- y[[i]] - medians[[i]]
  }
}

## Example data
x <- data.frame(matrix(
  runif(500 * 1e4),
  ncol = 500
))

medians <- vapply(x, median, numeric(1))

# Perform proof
## NB: This would be performed live in your browser!
results <- bench::mark(
  method_1(x, medians),
  method_2(x, medians)
)

print(results)

message(paste(
  "Method 2 is ",
  results$`itr/sec`[2] / results$`itr/sec`[1],
  " times faster than method 1"
))
```

### Ex. 3

What happens if you attempt to use tracemem() on an environment?

#### Answer

`tracemem()` will not trace it, because environments are not copied when they are modified. They are always modified in place. In the context of this notebook, it will fail due to webR not supporting memory profiling.

```{webr Ex 2.3.3 A}
#| autorun: true
#| error: TRUE
# Build objects for question
env_test <- rlang::env(
  a = 1,
  b = 2,
  c = 3
)

# Perform proof
tracemem(env_test)
```

